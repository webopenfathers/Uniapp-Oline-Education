var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { EVENTS, Sniffer, logger } from 'xgplayer-helper-utils';

var REMUX_EVENTS = EVENTS.REMUX_EVENTS;
var PLAYER_EVENTS = EVENTS.PLAYER_EVENTS;

var Mp4Remuxer = function () {
  function Mp4Remuxer() {
    var curTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    _classCallCheck(this, Mp4Remuxer);

    this.TAG = 'Mp4Remuxer';
    this._dtsBase = curTime * 1000;
    this._audioDtsBase = null;
    this._videoDtsBase = null;
    this._isDtsBaseInited = false;
    var browser = Sniffer.browser;

    this._fillSilenceFrame = browser === 'ie';

    this.isFirstVideo = true;
    this.isFirstAudio = true;

    this.videoAllDuration = 0;
    this.audioAllDuration = 0;

    this.audioRemuxed = 0;
    this.videoRemuxed = 0;
  }

  _createClass(Mp4Remuxer, [{
    key: 'init',
    value: function init() {
      this.on(REMUX_EVENTS.REMUX_MEDIA, this.remux.bind(this));
      this.on(REMUX_EVENTS.REMUX_METADATA, this.onMetaDataReady.bind(this));
      this.on(REMUX_EVENTS.DETECT_CHANGE_STREAM, this.resetDtsBase.bind(this));
      this.on(REMUX_EVENTS.DETECT_FRAG_ID_DISCONTINUE, this.seek.bind(this));
      this.on(PLAYER_EVENTS.SEEK, this.seek.bind(this));
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._dtsBase = -1;
      this._isDtsBaseInited = false;
    }
  }, {
    key: 'remux',
    value: function remux() {
      var _context$getInstance = this._context.getInstance('TRACKS'),
          audioTrack = _context$getInstance.audioTrack,
          videoTrack = _context$getInstance.videoTrack;
      // console.log('_isDtsBaseInited: ',this._isDtsBaseInited);


      !this._isDtsBaseInited && this.calcDtsBase(audioTrack, videoTrack);

      // if (videoTrack.samples.length && this.videoRemuxed <= 1) {
      //   this.videoRemuxed += 1
      // }
      this._remuxVideo(videoTrack);
      //
      // ('remux audio');
      this._remuxAudio(audioTrack);

      logger.groupEnd();
    }
  }, {
    key: 'resetDtsBase',
    value: function resetDtsBase() {
      // for hls 中途切换 meta后seek
      this._dtsBase = 0;
      // this._isDtsBaseInited = false
    }
  }, {
    key: 'seek',
    value: function seek(time) {
      if (!this._isDtsBaseInited) {
        this._dtsBase = time * 1000;
      } else {
        this._isDtsBaseInited = false;
        this._dtsBase = time * 1000;
      }

      this._audioDtsBase = this._videoDtsBase = null;
    }
  }, {
    key: 'onMetaDataReady',
    value: function onMetaDataReady(type) {}
  }, {
    key: 'calcDtsBase',
    value: function calcDtsBase(audioTrack, videoTrack) {
      if (!audioTrack && videoTrack.samples.length) {
        var firstSample = videoTrack.samples[0];
        var _start = void 0;
        if (firstSample.options && firstSample.options.start) {
          _start = firstSample.options.start;
        }
        this._videoDtsBase = firstSample.dts - (_start || this._dtsBase);
        this._isDtsBaseInited = true;
        return;
      }

      if ((!audioTrack || !audioTrack.samples.length) && (!videoTrack || !videoTrack.samples.length)) {
        return;
      }

      var audioBase = null;
      var videoBase = null;
      var start = null;
      if (audioTrack && audioTrack.samples && audioTrack.samples.length) {
        var _firstSample = audioTrack.samples[0];
        audioBase = _firstSample.dts;
        if (_firstSample.options && _firstSample.options.start) {
          start = _firstSample.options.start;
        }
      }
      if (videoTrack && videoTrack.samples && videoTrack.samples.length) {
        var _firstSample2 = videoTrack.samples[0];
        videoBase = _firstSample2.dts;
        if (_firstSample2.options && _firstSample2.options.start) {
          start = _firstSample2.options.start;
        }
      }

      this._videoDtsBase = (videoBase || audioBase) - (start || this._dtsBase);
      this._audioDtsBase = (audioBase || videoBase) - (start || this._dtsBase);
      this._dtsBase = Math.min(videoBase, audioBase);
      this._isDtsBaseInited = true;

      logger.log(this.TAG, 'calcDtsBase');
      logger.log(this.TAG, 'video first dts: ' + videoBase + ' , start:' + start + ' , _videoDtsBase:' + this._videoDtsBase + ' , _dtsBase:' + this._dtsBase);
      logger.log(this.TAG, 'audio first dts: ' + audioBase + ' , start:' + start + ' , _audioDtsBase:' + this._audioDtsBase + ', _dtsBase:' + this._dtsBase);
    }
  }, {
    key: '_remuxVideo',
    value: function _remuxVideo(videoTrack) {
      var track = videoTrack || {};

      if (!videoTrack || !videoTrack.samples || !videoTrack.samples.length) {
        return;
      }

      var samples = track.samples;

      var firstDts = -1;

      var maxLoop = 10000;
      while (samples.length && maxLoop-- > 0) {
        var avcSample = samples.shift();

        var isKeyframe = avcSample.isKeyframe,
            options = avcSample.options;

        if (!this.isFirstVideo && options && options.meta) {
          initSegment = this.remuxInitSegment('video', options.meta);
          options.meta = null;
          samples.unshift(avcSample);
          if (!options.isContinue) {
            this._videoDtsBase = 0;
          }
          break;
        }
        var dts = Math.max(0, avcSample.dts - this.videoDtsBase);
        if (firstDts === -1) {
          firstDts = dts;
        }

        var cts = void 0;
        var pts = void 0;
        if (avcSample.pts !== undefined) {
          pts = avcSample.pts - this._dtsBase;
          cts = pts - dts;
        }
        if (avcSample.cts !== undefined) {
          pts = avcSample.cts + dts;
          cts = avcSample.cts;
        }
      }

      this.isFirstVideo = false;
      this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'video');

      track.samples = [];
      track.length = 0;
    }
  }, {
    key: '_remuxAudio',
    value: function _remuxAudio(track) {
      var _ref = track || {},
          samples = _ref.samples;

      var firstDts = -1;
      var mp4Samples = [];

      var initSegment = null;
      var mdatBox = {
        samples: []
      };
      if (!samples || !samples.length) {
        return;
      }

      var maxLoop = 10000;
      var isFirstDtsInited = false;
      while (samples.length && maxLoop-- > 0) {
        var sample = samples.shift();
        var data = sample.data,
            options = sample.options;

        if (!this.isFirstAudio && options && options.meta) {
          initSegment = this.remuxInitSegment('audio', options.meta);
          options.meta = null;
          samples.unshift(sample);
          if (!options.isContinue) {
            this._audioDtsBase = 0;
          }
          break;
        }

        var dts = Math.max(0, sample.dts - this.audioDtsBase);
        var originDts = sample.originDts;
        if (!isFirstDtsInited) {
          firstDts = dts;
          isFirstDtsInited = true;
        }

        var sampleDuration = 0;
        if (sample.duration) {
          sampleDuration = sample.duration;
        } else if (this.audioMeta.refSampleDurationFixed) {
          sampleDuration = this.audioMeta.refSampleDurationFixed;
        } else if (samples.length >= 1) {
          var nextDts = samples[0].dts - this.audioDtsBase;
          sampleDuration = nextDts - dts;
        } else {
          if (mp4Samples.length >= 1) {
            // use second last sample duration
            sampleDuration = mp4Samples[mp4Samples.length - 1].duration;
          } else {
            // the only one sample, use reference sample duration
            sampleDuration = this.audioMeta.refSampleDuration;
          }
        }

        if (logger.long) {
          logger.log(this.TAG, 'audio dts ' + dts, 'pts ' + dts, 'originDts ' + originDts, 'duration ' + sampleDuration);
        }
        this.audioAllDuration += sampleDuration;
        var mp4Sample = {
          dts: dts,
          pts: dts,
          cts: 0,
          size: data.byteLength,
          duration: sample.duration ? sample.duration : sampleDuration,
          flags: {
            isLeading: 0,
            dependsOn: 1,
            isDependedOn: 0,
            hasRedundancy: 0,
            isNonSync: 0
          },
          isKeyframe: true,
          originDts: originDts,
          type: 'audio'
        };

        var mdatSample = {
          buffer: [],
          size: 0
        };

        if (sampleDuration >= 0) {
          mdatSample.buffer.push(data);
          mdatSample.size += data.byteLength;

          mdatBox.samples.push(mdatSample);
          mp4Samples.push(mp4Sample);
        }
      }

      var moofMdat = new Buffer();

      if (mp4Samples.length) {
        logger.log(this.TAG, 'remux to mp4 audio:', [firstDts / 1000, mp4Samples[mp4Samples.length - 1].dts / 1000]);
        var moof = Fmp4.moof({
          id: track.meta.id,
          time: firstDts,
          samples: mp4Samples
        });
        var mdat = Fmp4.mdat(mdatBox);
        moofMdat.write(moof, mdat);

        this.writeToSource('audio', moofMdat, mp4Samples[mp4Samples.length - 1].dts - mp4Samples[0].dts);
      }

      if (initSegment) {
        this.writeToSource('audio', initSegment);
        if (samples.length) {
          // second part of stream change
          track.samples = samples;
          return this._remuxAudio(track);
        }
      }

      this.isFirstAudio = false;
      this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'audio', moofMdat);

      track.samples = [];
      track.length = 0;
    }
  }, {
    key: 'writeToSource',
    value: function writeToSource(type, buffer, bufferDuration) {
      var presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');
      var source = presourcebuffer.getSource(type);
      if (!source) {
        source = presourcebuffer.createSource(type);
      }
      source.data.push(buffer);
      if (bufferDuration) {
        source.bufferDuration += bufferDuration;
      }
    }
  }, {
    key: 'initSilentAudio',
    value: function initSilentAudio(dts, duration) {
      var unit = Mp4Remuxer.getSilentFrame(this._audioMeta.channelCount);
      return {
        dts: dts,
        pts: dts,
        cts: 0,
        duration: duration,
        unit: unit,
        size: unit.byteLength,
        originDts: dts,
        type: 'video'
      };
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._player = null;
    }
  }, {
    key: 'videoMeta',
    get: function get() {
      return this._context.getInstance('TRACKS').videoTrack.meta;
    }
  }, {
    key: 'audioMeta',
    get: function get() {
      return this._context.getInstance('TRACKS').audioTrack.meta;
    }
  }, {
    key: 'videoDtsBase',
    get: function get() {
      if (this._videoDtsBase !== null) {
        return this._videoDtsBase;
      }
      return this._dtsBase;
    }
  }, {
    key: 'audioDtsBase',
    get: function get() {
      if (this._audioDtsBase !== null) {
        return this._audioDtsBase;
      }
      return this._dtsBase;
    }
  }], [{
    key: 'getSilentFrame',
    value: function getSilentFrame(channelCount) {
      if (channelCount === 1) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
      } else if (channelCount === 2) {
        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
      } else if (channelCount === 3) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
      } else if (channelCount === 4) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
      } else if (channelCount === 5) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
      } else if (channelCount === 6) {
        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
      }
      return null;
    }
  }]);

  return Mp4Remuxer;
}();

export default Mp4Remuxer;