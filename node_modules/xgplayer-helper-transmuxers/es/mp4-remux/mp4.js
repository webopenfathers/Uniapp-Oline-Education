var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import Buffer from './buffer';
import Fmp4 from './fmp4';

var Mp4 = function (_Fmp) {
  _inherits(Mp4, _Fmp);

  function Mp4() {
    _classCallCheck(this, Mp4);

    return _possibleConstructorReturn(this, (Mp4.__proto__ || Object.getPrototypeOf(Mp4)).apply(this, arguments));
  }

  _createClass(Mp4, null, [{
    key: 'moov',
    value: function moov(_ref) {
      var type = _ref.type,
          meta = _ref.meta;

      var size = 8;
      var mvhd = Mp4.mvhd(meta.duration, meta.timescale);
      var trak = void 0;

      if (type === 'video') {
        trak = Mp4.videoTrak(meta);
      } else {
        trak = Mp4.audioTrak(meta);
      }

      [mvhd, trak].forEach(function (item) {
        size += item.byteLength;
      });
      return Mp4.initBox(size, 'moov', mvhd, trak);
    }
  }, {
    key: 'videoTrak',
    value: function videoTrak(data) {
      var size = 8;

      var tkhd = Mp4.tkhd({
        id: 1,
        duration: data.duration,
        timescale: data.timescale || 1000,
        width: data.presentWidth,
        height: data.presentHeight,
        type: 'video'
      });
      var mdia = Mp4.mdia({
        type: 'video',
        timescale: data.timescale || 1000,
        duration: data.duration,
        avcc: data.avcc,
        parRatio: data.parRatio,
        width: data.presentWidth,
        height: data.presentHeight,
        streamType: data.streamType,
        sampleDeltas: data.sampleDeltas,
        keyFrames: data.keyFrames,
        sampleCtss: data.sampleCtss,
        chunks: data.chunks,
        sampleSizes: data.sampleSizes,
        chunksOffset: data.chunksOffset
      });
      [tkhd, mdia].forEach(function (item) {
        size += item.byteLength;
      });
      return Mp4.initBox(size, 'trak', tkhd, mdia);
    }
  }, {
    key: 'audioTrak',
    value: function audioTrak(data) {
      var size = 8;
      var tkhd = Mp4.tkhd({
        id: 2,
        duration: data.duration,
        timescale: data.timescale || 1000,
        width: 0,
        height: 0,
        type: 'audio'
      });
      var mdia = Mp4.mdia({
        type: 'audio',
        timescale: data.timescale || 1000,
        duration: data.duration,
        channelCount: data.channelCount,
        samplerate: data.sampleRate,
        config: data.config,
        sampleDeltas: data.sampleDeltas,
        keyFrames: data.keyFrames,
        sampleCtss: data.sampleCtss,
        chunks: data.chunks,
        sampleSizes: data.sampleSizes,
        chunksOffset: data.chunksOffset
      });
      [tkhd, mdia].forEach(function (item) {
        size += item.byteLength;
      });
      return Mp4.initBox(size, 'trak', tkhd, mdia);
    }
  }, {
    key: 'mdia',
    value: function mdia(data) {
      var size = 8;
      var mdhd = Mp4.mdhd(data.timescale, data.duration);
      var hdlr = Mp4.hdlr(data.type);
      var minf = Mp4.minf(data);
      [mdhd, hdlr, minf].forEach(function (item) {
        size += item.byteLength;
      });
      return Mp4.initBox(size, 'mdia', mdhd, hdlr, minf);
    }
  }, {
    key: 'minf',
    value: function minf(data) {
      var size = 8;
      var vmhd = data.type === 'video' ? Mp4.vmhd() : Mp4.smhd();
      var dinf = Mp4.dinf();
      var stbl = Mp4.stbl(data);
      [vmhd, dinf, stbl].forEach(function (item) {
        size += item.byteLength;
      });
      return Mp4.initBox(size, 'minf', vmhd, dinf, stbl);
    }
  }, {
    key: 'stbl',
    value: function stbl(data) {
      var size = 8;
      var stsd = Mp4.stsd(data);
      var stts = Mp4.stts(data.sampleDeltas);
      var stss = void 0;
      if (data.keyFrames) {
        stss = Mp4.stss(data.keyFrames);
      }
      var ctts = void 0;
      if (data.sampleCtss) {
        ctts = Mp4.ctts(data.sampleCtss);
      }
      var stsc = Mp4.stsc(data.chunks);
      var stsz = Mp4.stsz(data.sampleSizes);
      var stco = Mp4.stco(data.chunksOffset);
      var tables = [stsd, stts, stsc, stsz, stco];
      if (stss) {
        tables.push(stss);
      }
      if (ctts) {
        tables.push(ctts);
      }

      tables.forEach(function (item) {
        // [stsd, stts, stss, stsc, stsz, stco].forEach(item => {
        size += item.byteLength;
      });
      return Mp4.initBox.apply(Mp4, [size, 'stbl'].concat(tables));
      // return Mp4.initBox(size, 'stbl', stsd, stts, stss, stsc, stsz, stco)
    }
    /**
     * @description dts-sample的映射表，可以计算出每个sample的dts
     * @param {object} data
     */

  }, {
    key: 'stts',
    value: function stts(data) {
      var entryCount = data.length;
      var uCount = new Uint8Array([entryCount >> 24, entryCount >> 16 & 0xff, entryCount >> 8 & 0xff, entryCount & 0xff]);
      var entryByteLength = 8 * entryCount;
      var uEntry = new Uint8Array(entryByteLength);
      var offset = 0;
      for (var i = 0; i < entryCount; i++) {
        var count = data[i].deltaCount;
        var delta = data[i].delta;
        var uDelta = new Uint8Array([count >> 24, count >> 16 & 0xff, count >> 8 & 0xff, count & 0xff, delta >> 24, delta >> 16 & 0xff, delta >> 8 & 0xff, delta & 0xff]);
        uEntry.set(uDelta, offset);
        offset += 8;
      }
      var buffer = new Buffer();
      buffer.write(Mp4.size(12 + 4 + entryByteLength), Mp4.type('stts'), Mp4.extension(0, 0), uCount, uEntry);
      return buffer.buffer;
    }

    /**
     * @description 可以计算出pts，保存了每个sample与dts的差值
     * @param {object} data
     */

  }, {
    key: 'ctts',
    value: function ctts(data) {
      var entryCount = data.length;
      var uCount = new Uint8Array([entryCount >> 24, entryCount >> 16 & 0xff, entryCount >> 8 & 0xff, entryCount & 0xff]);
      var entryByteLength = 8 * entryCount;
      var uEntry = new Uint8Array(entryByteLength);
      var offset = 0;
      for (var i = 0; i < entryCount; i++) {
        var count = data[i].ctsCount;
        var delta = data[i].cts;
        var uDelta = new Uint8Array([count >> 24, count >> 16 & 0xff, count >> 8 & 0xff, count & 0xff, delta >> 24, delta >> 16 & 0xff, delta >> 8 & 0xff, delta & 0xff]);
        uEntry.set(uDelta, offset);
        offset += 8;
      }
      var buffer = new Buffer();
      buffer.write(Mp4.size(12 + 4 + entryByteLength), Mp4.type('ctts'), Mp4.extension(0, 0), uCount, uEntry);
      return buffer.buffer;
    }

    /**
     * @description trunk和sample的映射表
     * @param {object} data
     */

  }, {
    key: 'stsc',
    value: function stsc(data) {
      var entryCount = data.length;
      var uCount = new Uint8Array([entryCount >> 24, entryCount >> 16 & 0xff, entryCount >> 8 & 0xff, entryCount & 0xff]);
      var entrySize = 12;
      var entryByteLength = entrySize * entryCount;
      var uEntry = new Uint8Array(entryByteLength);
      var offset = 0;
      for (var i = 0; i < entryCount; i++) {
        var firstChunk = data[i].firstChunk;
        var samplesPerChunk = data[i].samplesPerChunk;
        var index = data[i].sampleDescIndex;
        var uDelta = new Uint8Array([firstChunk >> 24, firstChunk >> 16 & 0xff, firstChunk >> 8 & 0xff, firstChunk & 0xff, samplesPerChunk >> 24, samplesPerChunk >> 16 & 0xff, samplesPerChunk >> 8 & 0xff, samplesPerChunk & 0xff, index >> 24, index >> 16 & 0xff, index >> 8 & 0xff, index & 0xff]);
        uEntry.set(uDelta, offset);
        offset += entrySize;
      }
      var buffer = new Buffer();
      buffer.write(Mp4.size(12 + 4 + entryByteLength), Mp4.type('stsc'), Mp4.extension(0, 0), uCount, uEntry);
      return buffer.buffer;
    }

    /**
     * @description 每个sample的字节数
     */

  }, {
    key: 'stsz',
    value: function stsz(data) {
      var count = data.length;
      var entryByteLength = 4 * count;
      var uSampleSize = new Uint8Array([0x00, 0x00, 0x00, 0x00]);
      var uCount = new Uint8Array([count >> 24, count >> 16 & 0xff, count >> 8 & 0xff, count & 0xff]);
      var uEntry = new Uint8Array(entryByteLength);
      var offset = 0;
      for (var i = 0; i < count; i++) {
        var size = data[i];
        var uSize = new Uint8Array([size >> 24, size >> 16 & 0xff, size >> 8 & 0xff, size & 0xff]);
        uEntry.set(uSize, offset);
        offset += 4;
      }
      var buffer = new Buffer();
      // headersize + countsize + entryByteLength
      buffer.write(Mp4.size(12 + 4 + 4 + entryByteLength), Mp4.type('stsz'), Mp4.extension(0, 0), uSampleSize, uCount, uEntry);
      return buffer.buffer;
    }

    /**
     * @description 关键帧列表，表示哪个sample时关键帧
     */

  }, {
    key: 'stss',
    value: function stss(data) {
      var count = data.length;
      var entryByteLength = 4 * count;
      var uCount = new Uint8Array([count >> 24, count >> 16 & 0xff, count >> 8 & 0xff, count & 0xff]);
      var uEntry = new Uint8Array(entryByteLength);
      var offset = 0;
      for (var i = 0; i < count; i++) {
        var index = data[i];
        var uDelta = new Uint8Array([index >> 24, index >> 16 & 0xff, index >> 8 & 0xff, index & 0xff]);
        uEntry.set(uDelta, offset);
        offset += 4;
      }
      var buffer = new Buffer();
      // headersize + countsize + entryByteLength
      buffer.write(Mp4.size(12 + 4 + entryByteLength), Mp4.type('stss'), Mp4.extension(0, 0), uCount, uEntry);
      return buffer.buffer;
    }

    /**
     * @description chunk offset表，存储了chunk在文件中的偏移量
     */

  }, {
    key: 'stco',
    value: function stco(data) {
      var count = data.length;
      var entryByteLength = 4 * count;

      var uCount = new Uint8Array([count >> 24, count >> 16 & 0xff, count >> 8 & 0xff, count & 0xff]);
      var uEntry = new Uint8Array(entryByteLength);
      var offset = 0;
      for (var i = 0; i < count; i++) {
        var size = data[i];
        var uSize = new Uint8Array([size >> 24, size >> 16 & 0xff, size >> 8 & 0xff, size & 0xff]);
        uEntry.set(uSize, offset);
        offset += 4;
      }
      var buffer = new Buffer();

      buffer.write(Mp4.size(12 + 4 + entryByteLength), Mp4.type('stco'), Mp4.extension(0, 0), uCount, uEntry);
      return buffer.buffer;
    }
  }]);

  return Mp4;
}(Fmp4);

export default Mp4;