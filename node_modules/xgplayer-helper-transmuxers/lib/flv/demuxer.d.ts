export default FlvDemuxer;
declare class FlvDemuxer {
    /**
     * if the flv head is valid
     * @param data
     * @returns {boolean}
     */
    static isFlvFile(data: any): boolean;
    /**
     * If the stream has audio or video.
     * @param {number} streamFlag - Data from the stream which is define whether the audio / video track is exist.
     */
    static getPlayType(streamFlag: number): {
        hasVideo: boolean;
        hasAudio: boolean;
    };
    /** @type {boolean} */
    headerParsed: boolean;
    /** @type {number} */
    trackNum: number;
    /** @type {boolean} */
    hasScript: boolean;
    /** @type {boolean} */
    _videoMetaChange: boolean;
    /** @type {boolean} */
    _audioMetaChange: boolean;
    /** @type {number} */
    gopId: number;
    /** @type {*}  */
    onMetaData: any;
    demux(buffer: any): void;
    parseFlvHeader(header: any): void;
    /**
     * Package the data as the following data structure
     * {
     *    data: Uint8Array. the Stream data.
     *    info: The first byte info of the Tag.
     *    tagType: 8、9、18
     *    timeStamp: the timestemp
     * }
     */
    _parseFlvTag(buffer: any): FlvTag;
    /**
     * Parse the 11 byte tag Header
     */
    _parseFlvTagHeader(buffer: any): FlvTag;
    _processTagData(flvTag: any, buffer: any): void;
    /**
     * parse flv script data
     * @param flvTag
     * @private
     */
    private _parseScriptData;
    _aacSequenceHeaderParser(data: any): {
        hasSpecificConfig: boolean;
        objectType: number;
        originObjectType: number;
        sampleRateIndex: number;
        audiosamplerate: number;
        channelCount: number;
        frameLength: number;
        dependsOnCoreCoder: number;
        extensionFlagIndex: number;
        codec: string;
        config: any[];
    };
    _parseAudioTag(tag: any, buffer: any): void;
    _parseVideoData(flvTag: any, buffer: any): void;
    /**
     * parse avc metadata
     *  configurationVerison = 1  uint(8)
     *  avcProfileIndication      uint(8)
     *  profile_compatibility     uint(8)
     *  avcLevelIndication        uint(8)
     *  reserved   `111111`       bit(6)
     *  lengthSizeMinusOne        uint(2)
     *  reserved   `111`          bit(3)
     *  numOfSPS                  uint(5)
     *  for(numOfSPS)
     *    spsLength               uint(16)
     *    spsNALUnit              spsLength个字节
     *  numOfPPS                  uint(8)
     *  for(numOfPPS)
     *     ppsLength              uint(16)
     *     ppsNALUnit             ppsLength个字节
     */
    _avcSequenceHeaderParser(data: any): VideoTrackMeta;
    /**
     * parse hevc metadata
     *  configurationVerison = 1  uint(8)
     *  generalProfileSpace       uint(2)
     *  generalTierFlag           uint(1)
     *  generalProfileIdc         uint(5)
     *  generalProfileCompatibilityFlags uint(32)
     *  generalConstraintIndicatorFlags  uint(48)
     *  generalLevelIdc           uint(8)
     *  complete_representation   bit(1)
     *  reserved   `111`          bit(3)
     *  segmentationIdc           uint(12)
     *  reserved `111111`         bit(6)
     *  parallelismType           uint(2)
     *  reserved `111111`         bit(6)
     *  chromaFormat              uint(2)
     *  reserved `11111`          bit(5)
     *  bitDepthLumaMinus8        uint(3)
     *  reserved `11111`          bit(5)
     *  bitDepthChromaMinus8      uint(3)
     *  avgFrameRate              bit(16)
     *  constantFrameRate         bit(2)
     *  numTemporalLayers         bit(3)
     *  temporalIdNested          bit(1)
     *  lengthSizeMinusOne        uint(2)
     *  numOfArrays               uint(8)
     *  for(numOfArrays)
     *    arrayCompleteness       bit(1)
     *    reserved                uint(1)
     *    nalUnitType             uint(16)
     *    numNals                 uint(16)
     *    for(numNals)
     *       nalUintLength        uint(16)
     *       nalUint              bit(8 * nalUintLength)
     */
    _hevcSequenceHeaderParser(data: any): VideoTrackMeta;
    /**
     * choose audio sample rate
     * @param samplingFrequencyIndex
     * @returns {number}
     * @private
     */
    private _switchAudioSampleRate;
    /**
     * choose audio sampling frequence
     * @param info
     * @returns {number}
     * @private
     */
    private _switchAudioSamplingFrequency;
    /**
     * choose audio channel count
     * @param info
     * @returns {number}
     * @private
     */
    private _switchAudioChannel;
    /**
     * check datasize is valid use 4 Byte after current tag
     * @param datasize
     * @returns {boolean}
     * @private
     */
    private _datasizeValidator;
    destroy(): void;
}
import { FlvTag } from "xgplayer-helper-models";
import { VideoTrackMeta } from "xgplayer-helper-models";
