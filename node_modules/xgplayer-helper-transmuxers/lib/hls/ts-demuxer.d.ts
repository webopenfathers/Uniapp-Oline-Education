export default TsDemuxer;
export type TsFrag = import('xgplayer-helper-models').TsFrag;
export type Buffer = import('xgplayer-helper-models').Buffer;
declare class TsDemuxer {
    static get EVENTS(): {
        DEMUX_COMPLETE: string;
        METADATA_PARSED: string;
        VIDEO_SAMPLE_PARSED: string;
        AUDIO_SAMPLE_PARSED: string;
        SEI_PARSED: string;
    };
    static compareArray(a: any, b: any, type: any): boolean;
    static compareMeta(a: any, b: any, ignoreDuration: any): boolean;
    static mergeVideoES(buffers: any): XGDataView;
    static mergeAudioES(buffers: any): XGDataView;
    static read(stream: any, ts: any, frags: any): void;
    static readPayload(stream: any, ts: any, frags: any): void;
    static readHeader(stream: any, ts: any): void;
    static PAT(stream: any, ts: any, frags: any): void;
    /**
     * ISO-13818-1 Table-2-25
     * payload 针对 PMT:
     *  1 字节： table id [table 第一字节]
     *  section_length : 12bit 【table 第2字节后四位，3字节】
     *  program_number : 16bit 【table第4，5字节】
     *  program_info_length : 12bit 【table 第11字节后 4bit + 第12 byte】
     *  N * 8 : descriptor
     *    stream_type : 8bit
     *    pid
     *
     * // 4 字节
     *  reserved : 3bit
     *  elementary_PID : 13bit
     *  reserved : 4bit
     *  ES_info_length: 12bit
     */
    static PMT(stream: any, ts: any, frags: any): void;
    static Media(stream: any, ts: any, streamType: any): void;
    /**
     * http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
     * ISO-13818-1 Table-2-17
     * packet_start_code_prefix : 24bit 0x000001
     * stream_id : 8bit
     * PES_packet_length : 16bit
     * PTS_DTS_flags : 2bit 【PES_packet_length后第2字节前2位】& 0xc0  [0x10 0x11]
     * PES_header_data_length : 【PTS_DTS_flags 后第1字节】
     *
     * | 6字节header | 3字节扩展 | PES Header data | payload |
     */
    static PES(ts: any): {
        ES: {
            buffer: any;
        };
        type: string;
        packetLength: any;
        ptsDTSFlag: number;
        escrFlag: number;
        esRateFlag: number;
        dsmFlag: number;
        additionalFlag: number;
        crcFlag: number;
        extensionFlag: number;
        pesHeaderLength: any;
        purePts: number;
        pts: number;
        dts: number;
        escr: number;
        esRate: number;
        additionalCopyInfo: number;
        pesCRC: any;
    };
    static ES(buffer: any, type: any, streamType: any): {
        buffer: any;
    };
    static parseADTSHeader(buffer: any): {
        id: string;
        layer: number;
        absent: number;
        audioObjectType: number;
        profile: number;
        frequencyIndex: number;
        frequence: number;
        channel: number;
        frameLength: number;
        buffer: any;
    };
    static TSDT(stream: any, ts: any, frags: any): void;
    static CAT(stream: any, ts: any, frags: any): void;
    static getAudioConfig(ret: any): void;
    /**
     * @param {any} videoTrack
     * @param {any} audioTrack
     */
    constructor({ videoTrack, audioTrack }: any);
    TAG: string;
    demuxing: boolean;
    videoTrack: any;
    audioTrack: any;
    pat: any[];
    pmt: any[];
    _hasVideoMeta: boolean;
    _hasAudioMeta: boolean;
    gopId: number;
    /**
     *
     * @param {TsFrag} frag ts fragment parsed from m3u8
     * @param {Buffer} buffer u8a-buffer
     * @param {boolean} isVod is a vod m3u8
     */
    demux(frag: TsFrag, buffer: Buffer, isVod: boolean): void;
    pushAudioSample(pes: any, options: any): void;
    pushVideoSample(pes: any, options: any): void;
    pushVideoSampleHEVC(pes: any, options: any): void;
    destroy(): void;
    configs: {};
}
import { XGDataView } from "xgplayer-helper-models";
