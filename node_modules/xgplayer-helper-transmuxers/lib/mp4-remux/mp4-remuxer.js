'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _xgplayerHelperUtils = require('xgplayer-helper-utils');

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _buffer = require('./buffer');

var _buffer2 = _interopRequireDefault(_buffer);

var _mp = require('./mp4');

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-useless-return */


var DEFAULT_SAMPLE_DURATION = 40;

var Mp4Box = function (_EventEmitter) {
  _inherits(Mp4Box, _EventEmitter);

  function Mp4Box(_ref) {
    var videoMeta = _ref.videoMeta,
        audioMeta = _ref.audioMeta,
        curTime = _ref.curTime,
        options = _ref.options;

    _classCallCheck(this, Mp4Box);

    var _this = _possibleConstructorReturn(this, (Mp4Box.__proto__ || Object.getPrototypeOf(Mp4Box)).call(this));

    _this._dtsBase = curTime * 1000;
    _this._options = options || {};
    _this._samplePerChunk = _this._options.sampleNumberPerChunk || 100;
    _this._videoMeta = videoMeta;
    _this._audioMeta = audioMeta;

    _this._audioDtsBase = null;
    _this._videoDtsBase = -1;
    _this._isDtsBaseInited = false;

    _this.isFirstVideo = true;
    _this.isFirstAudio = true;

    _this.videoAllDuration = 0;
    _this.audioAllDuration = 0;
    _this.audioSamples = [];
    _this.audioRemuxed = 0;
    _this.videoRemuxed = 0;
    _this.mp4Durations = {
      keys: []
    };
    _this.ctsNum = 0;
    return _this;
  }

  _createClass(Mp4Box, [{
    key: 'destroy',
    value: function destroy() {
      this._dtsBase = -1;
      this._isDtsBaseInited = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack) {
      if (!audioTrack && !videoTrack) {
        return;
      }
      if (!videoTrack) {
        this.remuxMp4(audioTrack, 'audio');
      }
      if (!audioTrack) {
        this.remuxMp4(videoTrack, 'video');
      }
      if (audioTrack && videoTrack) {
        this.remuxMix(audioTrack, videoTrack);
      }

      _xgplayerHelperUtils.logger.groupEnd();
    }

    /**
     * @description 生成包含音频和视频的mp4
     * @param {*} audioTrack 音频track
     * @param {*} videoTrack 视频track
     * @returns null
     */

  }, {
    key: 'remuxMix',
    value: function remuxMix(audioTrack, videoTrack) {
      if (!audioTrack || !audioTrack.samples || !audioTrack.samples.length) {
        return;
      }
      if (!videoTrack || !videoTrack.samples || !videoTrack.samples.length) {
        return;
      }

      var audioSamples = audioTrack.samples,
          audioMeta = audioTrack.meta;
      var videoSamples = videoTrack.samples,
          videoMeta = videoTrack.meta;


      if (!audioMeta || !videoMeta) {
        return;
      }
      // 如果是音视频都有，每个chunk有一个sample
      this._samplePerChunk = 1;

      var mdat = null;
      var moov = null;
      // 1 构造ftyp
      var ftyp = _mp2.default.ftyp();
      var mdatBox = {
        samples: []
      };

      var firstAudioSample = audioSamples[0];
      var firstVideoSample = videoSamples[0];
      var baseDts = Math.min(firstAudioSample.dts, firstVideoSample.dts);
      var trackInfo = {
        offset: ftyp.byteLength + 8,
        audio: {
          meta: audioMeta,
          samples: audioSamples,
          length: audioSamples.length,
          sampleDuration: 0,
          trackDuration: 0,
          frameIndex: 0,
          deltas: [], // 存储每个sample的duration
          sampleCtss: [],
          chunks: [],
          sampleSizes: [],
          chunksOffset: []
        },
        video: {
          meta: videoMeta,
          samples: videoSamples,
          length: videoSamples.length,
          sampleDuration: 0,
          trackDuration: 0,
          frameIndex: 0,
          deltas: [],
          sampleCtss: [],
          chunks: [],
          sampleSizes: [],
          chunksOffset: [],
          keyFrames: []
        }
      };
      var type = null;
      try {
        while (audioSamples.length || videoSamples.length) {
          var sample = void 0;
          if (audioSamples.length && videoSamples.length) {
            // 每次写入dts最小的sample
            if (audioSamples[0].dts < videoSamples[0].dts) {
              sample = audioSamples.shift();
              type = 'audio';
            } else {
              sample = videoSamples.shift();
              type = 'video';
            }
          }
          // 只有音频
          if (audioSamples.length && !videoSamples.length) {
            sample = audioSamples.shift();
            type = 'audio';
          }
          // 只有视频
          if (!audioSamples.length && videoSamples.length) {
            sample = videoSamples.shift();
            type = 'video';
          }

          var _sample = sample,
              isKeyframe = _sample.isKeyframe;

          var cts = void 0;
          var pts = void 0;
          var dts = Math.max(0, sample.dts - baseDts);

          if (sample.cts !== undefined && type === 'video') {
            pts = sample.cts + dts;
            cts = sample.cts;
          }
          var currentTrackInfo = trackInfo[type];
          var sampleDuration = this.getSttsBoxData(sample, currentTrackInfo.samples[0], currentTrackInfo.deltas);
          currentTrackInfo.trackDuration = this.getDuration(currentTrackInfo.trackDuration, sampleDuration);
          this.getCttsBoxData(cts, currentTrackInfo.sampleCtss);

          var mdatSample = {
            buffer: [],
            size: 0
          };
          var sampleByteSize = sample.data.byteLength;
          if (_xgplayerHelperUtils.logger.long) {
            _xgplayerHelperUtils.logger.log(this.TAG, type + ' dts ' + dts, 'pts ' + pts, 'cts: ' + cts, 'isKeyframe ' + isKeyframe, 'originDts ' + sample.originDts, 'duration ' + sampleDuration);
          }

          if (sampleDuration >= 0) {
            mdatBox.samples.push(mdatSample);
            mdatSample.buffer.push(sample.data);
            mdatSample.size += sampleByteSize;
          }
          currentTrackInfo.frameIndex++;
          this.getStszBoxData(sampleByteSize, currentTrackInfo.sampleSizes);
          trackInfo.offset = this.getStcoBoxData(currentTrackInfo.frameIndex, sampleByteSize, currentTrackInfo.length, trackInfo.offset, currentTrackInfo.chunksOffset);

          if (isKeyframe) {
            this.getStssBoxData(currentTrackInfo.frameIndex, currentTrackInfo.keyFrames);
          }
        }
      } catch (error) {
        console.error(error);
      }
      this.getStscBoxData(trackInfo.audio.length, trackInfo.audio.chunks);
      this.getStscBoxData(trackInfo.video.length, trackInfo.video.chunks);

      // 2构造mdat box
      if (mdatBox.samples.length) {
        mdat = _mp2.default.mdat(mdatBox);
      }

      // 3 构造moov box
      [{ meta: videoMeta, type: 'video' }, { meta: audioMeta, type: 'audio' }].forEach(function (item) {
        item.meta.duration = trackInfo[item.type].trackDuration;
        item.meta.sampleDeltas = trackInfo[item.type].deltas;
        item.meta.keyFrames = trackInfo[item.type].keyFrames;
        item.meta.sampleCtss = trackInfo[item.type].sampleCtss;
        item.meta.chunks = trackInfo[item.type].chunks;
        item.meta.sampleSizes = trackInfo[item.type].sampleSizes;
        item.meta.chunksOffset = trackInfo[item.type].chunksOffset;
      });

      moov = this.mixMoov(videoMeta.duration, videoMeta.timeScale, [videoMeta, audioMeta]);

      var mp4 = new _buffer2.default();
      mp4.write(ftyp, mdat, moov);
      this.emit(Mp4Box.EVENTS.TRACK_REMUXED, type, mp4);
      // 下载mp4文件到本地，测试用
      // this.downLoadMp4(mp4)
    }

    /**
     * @description remux单独的音频或者视频生成mp4文件
     * @param {*} track 音频或者视频的track对象
     * @param {*} type 表示track类型，'audio'或者'video'
     * @returns null
     */

  }, {
    key: 'remuxMp4',
    value: function remuxMp4() {
      var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var type = arguments[1];

      if (!track || !track.samples || !track.samples.length) {
        return;
      }

      var samples = track.samples,
          meta = track.meta;


      if (!meta) {
        return;
      }
      var frameIndex = 0;
      var mdat = null;
      var moov = null;
      // 1 构造ftyp
      var ftyp = _mp2.default.ftyp();
      var keyFrames = [];
      var mdatBox = {
        samples: []
      };

      var firstSample = samples[0];
      var baseDts = firstSample.dts || 0;
      var trackDuration = 0;
      var sampleDeltas = [];
      var sampleCtss = [];
      var chunks = [];
      var sampleSizes = [];
      var sampleCount = samples.length;
      var chunksOffset = [];
      var chunkOffset = ftyp.byteLength + 8;
      var maxLoop = 10000;
      try {
        while (samples.length && maxLoop-- > 0) {
          var currentSample = samples.shift();
          var isKeyframe = currentSample.isKeyframe;

          var cts = void 0;
          var pts = void 0;
          var dts = Math.max(0, currentSample.dts - baseDts);

          if (currentSample.pts !== undefined) {
            pts = currentSample.pts - baseDts;
            cts = pts - dts;
          }

          if (currentSample.cts !== undefined) {
            pts = currentSample.cts + dts;
            cts = currentSample.cts;
          }
          var sampleDuration = this.getSttsBoxData(currentSample, samples[0], sampleDeltas);
          trackDuration = this.getDuration(trackDuration, sampleDuration);
          this.getCttsBoxData(cts, sampleCtss);

          var mdatSample = {
            buffer: [],
            size: 0
          };
          var sampleByteSize = currentSample.data.byteLength;
          if (_xgplayerHelperUtils.logger.long) {
            _xgplayerHelperUtils.logger.log(this.TAG, 'video dts ' + dts, 'pts ' + pts, 'cts: ' + cts, isKeyframe, 'originDts ' + currentSample.originDts, 'duration ' + sampleDuration);
          }

          if (sampleDuration >= 0) {
            mdatBox.samples.push(mdatSample);
            mdatSample.buffer.push(currentSample.data);
            mdatSample.size += sampleByteSize;
          }
          frameIndex++;
          this.getStszBoxData(sampleByteSize, sampleSizes);
          chunkOffset = this.getStcoBoxData(frameIndex, sampleByteSize, sampleCount, chunkOffset, chunksOffset);

          if (isKeyframe) {
            this.getStssBoxData(frameIndex, keyFrames);
          }
        }
      } catch (error) {
        console.error(error);
      }

      meta.duration = trackDuration;
      this.getStscBoxData(sampleCount, chunks);

      // 2构造mdat box
      if (mdatBox.samples.length && track.meta) {
        mdat = _mp2.default.mdat(mdatBox);
      }

      // 3 构造moov box
      meta.sampleDeltas = sampleDeltas;
      meta.chunks = chunks;
      meta.sampleSizes = sampleSizes;
      meta.chunksOffset = chunksOffset;
      if (type === 'video') {
        meta.keyFrames = keyFrames;
        meta.sampleCtss = sampleCtss;
      }
      moov = _mp2.default.moov({ type: type, meta: meta });
      track.samples = [];
      track.length = 0;

      var mp4 = new _buffer2.default();
      mp4.write(ftyp, mdat, moov);
      this.emit(Mp4Box.EVENTS.TRACK_REMUXED, type, mp4);
      this.ctsNum = 0;
      // 下载mp4文件到本地，测试用
      // this.downLoadMp4(mp4)
    }

    /**
     * @description 生成音视频都有的mp4的moov
     * @param {*} duration 视频的时长
     * @param {*} timeScale 视频的timescale
     * @param {array} tracksMeta 音视频的meta
     * @returns null
     */

  }, {
    key: 'mixMoov',
    value: function mixMoov(duration, timeScale, tracksMeta) {
      var size = 8;
      var mvhd = _mp2.default.mvhd(duration, timeScale);
      var tracks = [];
      tracksMeta.forEach(function (item) {
        var track = void 0;
        if (item.type === 'video') {
          track = _mp2.default.videoTrak(item);
        } else {
          track = _mp2.default.audioTrak(item);
        }
        tracks.push(track);
      });
      var boxs = [mvhd].concat(tracks);
      boxs.forEach(function (item) {
        size += item.byteLength;
      });
      return _mp2.default.initBox.apply(_mp2.default, [size, 'moov', mvhd].concat(tracks));
    }

    /**
     * @description dts to sample的映射表
     * @param {*} sample 音频或者视频的一个sample
     * @param {*} nextSample sample的下一个sample
     * @param {*} sampleDeltas sample的duration
     * @returns sample的duration
     */

  }, {
    key: 'getSttsBoxData',
    value: function getSttsBoxData(sample, nextSample, sampleDeltas) {
      var duration = sample.duration;
      var len = sampleDeltas.length;
      var delta = void 0;
      // samples 数量大于等于2
      if (nextSample) {
        var dts = sample.dts;
        var nextDts = nextSample.dts;
        if (duration) {
          delta = duration;
        } else {
          delta = nextDts - dts;
        }
        if (!len) {
          sampleDeltas.push({ delta: delta, deltaCount: 1 });
          return delta;
        }
        if (delta === sampleDeltas[len - 1].delta) {
          sampleDeltas[len - 1].deltaCount += 1;
        } else {
          sampleDeltas.push({ delta: delta, deltaCount: 1 });
        }
      } else {
        // 最后一个sample
        // 只有一个sample
        if (!len) {
          sampleDeltas.push({ delta: DEFAULT_SAMPLE_DURATION, deltaCount: 1 });
          delta = DEFAULT_SAMPLE_DURATION;
        } else {
          // 默认最后一个sample的duration与前一个相同
          sampleDeltas[len - 1].deltaCount += 1;
          delta = sampleDeltas[len - 1].delta;
        }
      }
      return delta;
    }

    /**
     * @description 保存pts与dts的差值到ctsEntry，如果没有B帧，没有这个表
     * @param {*} cts 视频帧的cts
     * @param {*} ctsEntry 保存cts的数组
     * @returns null
     */

  }, {
    key: 'getCttsBoxData',
    value: function getCttsBoxData(cts, ctsEntry) {
      var len = ctsEntry.length;
      // 第一个sample
      if (!len) {
        this.ctsNum += 1;
        ctsEntry.push({ cts: cts, ctsCount: 1 });
        return;
      }

      if (ctsEntry[len - 1].cts === cts) {
        this.ctsNum += 1;
        ctsEntry[len - 1].ctsCount += 1;
      } else {
        this.ctsNum += 1;
        ctsEntry.push({ cts: cts, ctsCount: 1 });
      }
    }

    /**
     * @description 生成trunk与sample的映射关系表
     * @param {*} sampleCount 一共有多少个sample
     * @param {*} chunks 保存映射关系的数组
     */

  }, {
    key: 'getStscBoxData',
    value: function getStscBoxData(sampleCount, chunks) {
      if (sampleCount <= this._samplePerChunk) {
        chunks.push({ firstChunk: 1, samplesPerChunk: sampleCount, sampleDescIndex: 1 });
      } else {
        var len = Math.floor(sampleCount / this._samplePerChunk);
        var lastSampleNumber = sampleCount % this._samplePerChunk;
        chunks.push({ firstChunk: 1, samplesPerChunk: this._samplePerChunk, sampleDescIndex: 1 });
        if (lastSampleNumber) {
          chunks.push({ firstChunk: len + 1, samplesPerChunk: lastSampleNumber, sampleDescIndex: 1 });
        }
      }
    }

    /**
     * @description 生成chunk offset
     * @param {*} sampleIndex 当前sample的索引值
     * @param {*} sampleSize 当前sample的字节大小
     * @param {*} sampleCount track的sample的个数
     * @param {*} chunkOffset 当前sample在mp4文件中的字节便宜量
     * @param {*} chunksOffset 存储chunkoffset的数组
     * @returns 当前sample的字节偏移
     */

  }, {
    key: 'getStcoBoxData',
    value: function getStcoBoxData(sampleIndex, sampleSize, sampleCount, chunkOffset, chunksOffset) {
      if (sampleIndex % this._samplePerChunk === 0) {
        chunksOffset.push(chunkOffset);
      }
      chunkOffset += sampleSize;
      return chunkOffset;
    }

    /**
     * @description 把每个sample的字节大小存储到sampleSizes里
     * @param {int} sampleByteSize 每个sample的字节大小
     * @param {array} sampleSizes 存储字节大小的数组
     */

  }, {
    key: 'getStszBoxData',
    value: function getStszBoxData(sampleByteSize, sampleSizes) {
      sampleSizes.push(sampleByteSize);
    }

    /**
     * @description 把关键帧对应的index放到keyFrames数组中
     * @param {int} sampleIndex keyframe在所有sample中的索引值
     * @param {array} keyFrames 存储keyframe的index的数组
     */

  }, {
    key: 'getStssBoxData',
    value: function getStssBoxData(sampleIndex, keyFrames) {
      keyFrames.push(sampleIndex);
    }
  }, {
    key: 'getDuration',
    value: function getDuration(currentDuration, duration) {
      return currentDuration + duration;
    }
  }, {
    key: 'downLoadMp4',
    value: function downLoadMp4(mp4) {
      var url = window.URL.createObjectURL(new Blob([mp4.buffer]));
      var link = document.createElement('a');
      link.style.display = 'none';
      link.href = url;
      link.setAttribute('download', 'v.mp4');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }, {
    key: 'videoMeta',
    get: function get() {
      return this._videoMeta;
    },
    set: function set(meta) {
      this._videoMeta = meta;
    }
  }, {
    key: 'audioMeta',
    get: function get() {
      return this._audioMeta;
    },
    set: function set(meta) {
      this._audioMeta = meta;
    }
  }], [{
    key: 'EVENTS',
    get: function get() {
      return {
        MEDIA_SEGMENT: 'MEDIA_SEGMENT',
        INIT_SEGMENT: 'INIT_SEGMENT',
        RANDOM_ACCESS_POINT: 'RANDOM_ACCESS_POINT',
        TRACK_REMUXED: 'TRACK_REMUXED'
      };
    }
  }]);

  return Mp4Box;
}(_eventemitter2.default);

exports.default = Mp4Box;