import { createClass as _createClass, classCallCheck as _classCallCheck } from "./_virtual/_rollupPluginBabelHelpers.js";
var VTT_CHECK = /^WEBVTT/;
var VTT_STYLE = /^STYLE+$/;
var VTT_CUE = /^\:\:cue/;
var VTT_CUEND = /^}+$/;
var ASS_CHECK = /^\[Script Info\].*/;
var TIME_REGEX_LIST = [/[0-9]{1,3}:[0-9]{2}:[0-9]{2}\.[0-9]{1,3}-->[0-9]{1,3}:[0-9]{2}:[0-9]{2}\.[0-9]{1,3}/, /[0-9]{1,2}:[0-9]{2}\.[0-9]{1,3}-->[0-9]{1,2}:[0-9]{2}\.[0-9]{1,3}/, /[0-9]{1,2}\.[0-9]{1,3}-->[0-9]{1,2}\.[0-9]{1,3}/];
var MAX_COUNT = 50;
var ASS_FORMAT = /^Format:\s/;
var ASS_STYLE = /^Style:\s/;
var ASS_DIALOGUE = /^Dialogue:\s/;
function getSecond(arr) {
  var len = arr.length;
  if (len === 3) {
    return ((Number(arr[0]) * 60 + Number(arr[1])) * 60 * 1e3 + Number(arr[2]) * 1e3) / 1e3;
  } else if (len === 2) {
    return (Number(arr[0]) * 60 * 1e3 + Number(arr[1]) * 1e3) / 1e3;
  } else {
    return Number(arr[0]);
  }
}
function isNumber(str) {
  return /^(\-|\+)?\d+(\.\d+)?$/.test(str);
}
function htmlEncodeAll(e) {
  return e;
}
function getByIndex(i, arr) {
  if (i >= 0 && i < arr.length) {
    return arr[i];
  }
  return "";
}
var SubTitleParser = /* @__PURE__ */ function() {
  function SubTitleParser2() {
    _classCallCheck(this, SubTitleParser2);
  }
  _createClass(SubTitleParser2, null, [{
    key: "parseJson",
    value: function parseJson(list) {
      var ret = [];
      var count = 0;
      for (var i = 0; i < list.length; i++) {
        if (count >= MAX_COUNT) {
          count = 0;
        }
        if (count === 0) {
          var item = {
            start: list[i].start,
            list: [list[i]],
            end: list[i].end
          };
          ret.push(item);
        } else {
          ret[ret.length - 1].list.push(list[i]);
          ret[ret.length - 1].end = list[i].end;
        }
        count++;
      }
      return ret;
    }
  }, {
    key: "parse",
    value: function parse(str, fun) {
      var format = SubTitleParser2.checkFormat(str);
      if (!format) {
        fun({
          format
        });
      }
      try {
        var ret = [];
        if (format === "ass") {
          ret = SubTitleParser2.parseASS(str);
        } else if (format === "vtt") {
          ret = SubTitleParser2.parseVTT(str);
        }
        fun({
          format,
          list: ret.list,
          styles: ret.styles
        });
      } catch (error) {
        console.error(error);
        fun({
          format
        }, error);
      }
    }
  }, {
    key: "parseASSItem",
    value: function parseASSItem() {
      var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var values = str.split(",");
      var item = {};
      var text = "";
      try {
        var len = values.length - mode.length;
        if (len > 0) {
          text = values.splice(mode.length - 1, len + 1).join(",") + "";
        } else {
          text = values[values.length - 1] + "";
        }
        text = text.replace(/\\n+/g, "");
        text = htmlEncodeAll(text);
        values[mode.length - 1] = text;
        mode.map(function(key, index) {
          if (key === "end" || key === "start") {
            item[key] = getSecond(values[index].split(":"));
          } else if (key === "text") {
            item[key] = [values[index]];
          } else if (key === "layer") {
            item[key] = [values[index]];
            item.textTag = [values[index]];
          } else if (key === "style") {
            item[key] = [values[index]];
          } else {
            item[key] = Number(values[index]) ? Number(values[index]) : values[index];
          }
        });
        return item;
      } catch (error) {
        console.error(error);
        return {};
      }
    }
  }, {
    key: "parseASS",
    value: function parseASS(str) {
      var arr = str.split("\n");
      var retData = [];
      var i = 0;
      var groupCount = 0;
      var styles = [];
      var mode = [];
      var lastSubTitle = null;
      while (i < arr.length) {
        if (ASS_FORMAT.test(arr[i])) {
          mode = arr[i].replace(ASS_FORMAT, "").replace(/\s+/g, "").split(",");
          mode = mode.map(function(item) {
            return item.toLocaleLowerCase();
          });
        } else if (ASS_STYLE.test(arr[i])) {
          styles.push(arr[i].replace(ASS_STYLE, "").replace(/\s+/g, ""));
        } else if (ASS_DIALOGUE.test(arr[i])) {
          var subTitle = SubTitleParser2.parseASSItem(arr[i].replace(ASS_DIALOGUE, ""), mode);
          if (!lastSubTitle || !(subTitle.start === lastSubTitle.start && subTitle.end === lastSubTitle.end)) {
            lastSubTitle = subTitle;
            var group = null;
            if (groupCount % MAX_COUNT === 0) {
              group = {
                start: lastSubTitle.start,
                end: lastSubTitle.end,
                list: []
              };
              group.list.push(lastSubTitle);
              retData.push(group);
            } else {
              group = retData[retData.length - 1];
              group.end = lastSubTitle.end;
              group.list.push(lastSubTitle);
            }
            groupCount++;
          } else {
            try {
              var _lastSubTitle = lastSubTitle, text = _lastSubTitle.text, textTag = _lastSubTitle.textTag, style = _lastSubTitle.style;
              text.push(subTitle.text[0]);
              textTag.push(subTitle.textTag[0]);
              style.push(subTitle.style[0]);
            } catch (error) {
              console.error(error);
            }
          }
        }
        i++;
      }
      return {
        list: retData,
        style: {}
      };
    }
  }, {
    key: "parseVTTStyle",
    value: function parseVTTStyle(str, style) {
      var arr = str.split(":");
      if (arr.length > 1) {
        var keyArr = arr[0].trim().split("-");
        var key = "";
        if (keyArr.length > 1) {
          keyArr.map(function(item, index) {
            key += index === 0 ? item : item.charAt(0).toUpperCase() + item.slice(1);
          });
        } else {
          key = keyArr[0];
        }
        style[key] = arr[1].trim().replace(/;$/, "");
      }
      return style;
    }
  }, {
    key: "parseVTT",
    value: function parseVTT(str) {
      str = str.replace(VTT_CHECK, "");
      var arr = str.split("\n");
      var retData = [];
      var i = 0;
      var groupCount = 0;
      var lastSubTitle = null;
      var isLastSpace = false;
      var isCueStart = false;
      var styleInfo = null;
      var styleHeader = null;
      var styles = [];
      while (i < arr.length) {
        var _str = getByIndex(i, arr).trim();
        if (!_str || isLastSpace && isNumber(_str)) {
          isLastSpace = !_str;
        } else if (VTT_CUE.test(_str) && VTT_STYLE.test(getByIndex(i - 1, arr).trim())) {
          isCueStart = true;
          var cueMatch = /\((.+?)\)/g.exec(_str);
          if (!cueMatch) {
            styleHeader = "";
          } else {
            styleHeader = cueMatch[1];
          }
          styleInfo = "";
        } else if (isCueStart) {
          if (VTT_CUEND.test(_str)) {
            styles.push({
              key: styleHeader,
              style: styleInfo
            });
            styleInfo = null;
            styleHeader = null;
            isCueStart = false;
          } else {
            styleInfo += _str;
          }
        } else if (_str) {
          isLastSpace = false;
          var time = this.checkIsTime(arr[i]);
          if (time) {
            var subTitle = this.parseVttTime(time);
            if (!lastSubTitle || !(subTitle.start === lastSubTitle.start && subTitle.end === lastSubTitle.end)) {
              lastSubTitle = subTitle;
              lastSubTitle.text = [];
              lastSubTitle.textTag = [];
              var group = null;
              if (groupCount % MAX_COUNT === 0) {
                group = {
                  start: lastSubTitle.start,
                  end: lastSubTitle.end,
                  list: []
                };
                group.list.push(lastSubTitle);
                retData.push(group);
              } else {
                group = retData[retData.length - 1];
                group.end = lastSubTitle.end;
                group.list.push(lastSubTitle);
              }
              groupCount++;
            }
          } else {
            if (lastSubTitle) {
              var _lastSubTitle2 = lastSubTitle, text = _lastSubTitle2.text, textTag = _lastSubTitle2.textTag;
              var ret = this.parseVttText(arr[i]);
              text.push(ret.text);
              textTag.push(ret.tag);
            }
          }
          isLastSpace = false;
        }
        i++;
        continue;
      }
      return {
        list: retData,
        styles
      };
    }
  }, {
    key: "checkIsTime",
    value: function checkIsTime(str) {
      str = str.replace(/\s+/g, "");
      var i = 0;
      var match = null;
      while (i < TIME_REGEX_LIST.length) {
        match = TIME_REGEX_LIST[i].exec(str);
        if (match) {
          break;
        }
        i++;
      }
      return match ? match[0] : null;
    }
  }, {
    key: "parseVttText",
    value: function parseVttText(text) {
      var langMatch = /^(<?.+?>)/g.exec(text);
      var retText = "";
      var tag = "default";
      if (langMatch) {
        tag = langMatch[0].replace(/\<|\>|\&/g, "");
        var newReg = RegExp("^<".concat(tag, ">(([\\s\\S])*?)</").concat(tag, ">$"));
        var textMatch = newReg.exec(text);
        if (textMatch) {
          retText = textMatch[1];
        } else {
          retText = text;
          tag = "";
        }
      } else {
        retText = text;
      }
      var tagsReg = /<(\w+).(\w+)>/g;
      var re = tagsReg.exec(retText);
      while (re && re.length > 2) {
        retText = retText.replace(re[0], "<".concat(re[1], ' class="').concat(re[2], '">'));
        re = tagsReg.exec(retText);
      }
      return {
        tag,
        text: htmlEncodeAll(retText.replace(/\\n+/g, "<br/>"))
      };
    }
  }, {
    key: "parseVttTime",
    value: function parseVttTime(str) {
      var arr = str.split("-->");
      var start;
      var end = 0;
      if (arr.length === 2) {
        var aArr = arr[0].split(":");
        var bArr = arr[1].split(":");
        start = getSecond(aArr);
        end = getSecond(bArr);
      }
      return {
        start,
        end,
        time: str
      };
    }
  }, {
    key: "isVTT",
    value: function isVTT(str) {
      return VTT_CHECK.test(str);
    }
  }, {
    key: "isASS",
    value: function isASS(str) {
      return ASS_CHECK.test(str);
    }
  }, {
    key: "checkFormat",
    value: function checkFormat(str) {
      if (!str) {
        return null;
      }
      if (VTT_CHECK.test(str)) {
        return "vtt";
      } else if (ASS_CHECK.test(str)) {
        return "ass";
      }
      return null;
    }
  }]);
  return SubTitleParser2;
}();
export { SubTitleParser as default };
