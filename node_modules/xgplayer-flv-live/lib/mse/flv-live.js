'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _xgplayerHelperTransmuxers = require('xgplayer-helper-transmuxers');

var _xgplayerHelperUtils = require('xgplayer-helper-utils');

var _xgplayerHelperModels = require('xgplayer-helper-models');

var _xgplayerHelperCodec = require('xgplayer-helper-codec');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var REMUX_EVENTS = _xgplayerHelperUtils.EVENTS.REMUX_EVENTS;
var DEMUX_EVENTS = _xgplayerHelperUtils.EVENTS.DEMUX_EVENTS;
var LOADER_EVENTS = _xgplayerHelperUtils.EVENTS.LOADER_EVENTS;
var MSE_EVENTS = _xgplayerHelperUtils.EVENTS.MSE_EVENTS;

var Tag = 'FLVController';

var Logger = function () {
  function Logger() {
    _classCallCheck(this, Logger);
  }

  _createClass(Logger, [{
    key: 'warn',
    value: function warn() {}
  }]);

  return Logger;
}();

var FLV_ERROR = 'FLV_ERROR';

var FlvController = function () {
  function FlvController(player) {
    var configs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var mse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    _classCallCheck(this, FlvController);

    this.TAG = Tag;
    this.state = {
      initSegmentArrived: false,
      randomAccessPoints: []
    };
    this.configs = Object.assign({
      retryTimes: 3
    }, configs);

    this.mse = mse;

    this.bufferClearTimer = null;

    this._handleTimeUpdate = this._handleTimeUpdate.bind(this);
  }

  _createClass(FlvController, [{
    key: 'init',
    value: function init() {
      if (!this.mse) {
        this.mse = new _xgplayerHelperUtils.Mse({ container: this._player.video }, this._context);
        this.mse.init();
      }

      this.initComponents();
      this.initListeners();
    }
  }, {
    key: 'initComponents',
    value: function initComponents() {
      this._context.registry('FETCH_LOADER', _xgplayerHelperUtils.FetchLoader);
      this._context.registry('LOADER_BUFFER', _xgplayerHelperModels.Buffer);

      this._context.registry('FLV_DEMUXER', _xgplayerHelperTransmuxers.FlvDemuxer);
      this._context.registry('TRACKS', _xgplayerHelperModels.Tracks);

      this._context.registry('MP4_REMUXER', _xgplayerHelperTransmuxers.Mp4Remuxer)(this._player.currentTime);

      this._context.registry('PRE_SOURCE_BUFFER', _xgplayerHelperModels.RemuxedBufferManager);

      if (this._player.config.compatibility !== false) {
        this._context.registry('COMPATIBILITY', _xgplayerHelperCodec.Compat);
      }

      this._context.registry('LOGGER', Logger);
    }
  }, {
    key: 'initListeners',
    value: function initListeners() {
      this.on(LOADER_EVENTS.LOADER_DATALOADED, this._handleLoaderDataLoaded.bind(this));
      this.on(LOADER_EVENTS.LOADER_ERROR, this._handleNetworkError.bind(this));
      this.on(LOADER_EVENTS.LOADER_RETRY, this._handleFetchRetry.bind(this));

      this.on(DEMUX_EVENTS.MEDIA_INFO, this._handleMediaInfo.bind(this));
      this.on(DEMUX_EVENTS.METADATA_PARSED, this._handleMetadataParsed.bind(this));
      this.on(DEMUX_EVENTS.DEMUX_COMPLETE, this._handleDemuxComplete.bind(this));
      this.on(DEMUX_EVENTS.DEMUX_ERROR, this._handleDemuxError.bind(this));
      this.on(DEMUX_EVENTS.SEI_PARSED, this._handleSEIParsed.bind(this));

      this.on(REMUX_EVENTS.INIT_SEGMENT, this._handleAppendInitSegment.bind(this));
      this.on(REMUX_EVENTS.MEDIA_SEGMENT, this._handleMediaSegment.bind(this));
      this.on(REMUX_EVENTS.RANDOM_ACCESS_POINT, this._handleAddRAP.bind(this));
      this.on(REMUX_EVENTS.REMUX_ERROR, this._handleRemuxError.bind(this));
      this.on(MSE_EVENTS.SOURCE_UPDATE_END, this._handleSourceUpdateEnd.bind(this));
      this.on(MSE_EVENTS.MSE_ERROR, this._handleMseError.bind(this));

      this._player.on('timeupdate', this._handleTimeUpdate);
    }
  }, {
    key: '_handleMediaInfo',
    value: function _handleMediaInfo() {
      if (!this._context.mediaInfo) {
        this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('failed to get mediainfo'));
      }
    }
  }, {
    key: '_handleLoaderDataLoaded',
    value: function _handleLoaderDataLoaded() {
      this.emitTo('FLV_DEMUXER', DEMUX_EVENTS.DEMUX_START);
    }
  }, {
    key: '_handleMetadataParsed',
    value: function _handleMetadataParsed(type) {
      this.emit(REMUX_EVENTS.REMUX_METADATA, type);
    }
  }, {
    key: '_handleSEIParsed',
    value: function _handleSEIParsed(sei) {
      this._player.emit('SEI_PARSED', sei);
    }
  }, {
    key: '_handleDemuxComplete',
    value: function _handleDemuxComplete() {
      this.emit(REMUX_EVENTS.REMUX_MEDIA, 'flv');
    }
  }, {
    key: '_handleRemuxError',
    value: function _handleRemuxError(tag, err, fatal) {
      if (fatal === undefined) {
        fatal = false;
      }
      this._player.emit('error', {
        errorType: 'parse',
        ex: '[' + tag + ']: ' + err.message,
        errd: {}
      });
      this._onError(REMUX_EVENTS.REMUX_ERROR, tag, err, fatal);
    }
  }, {
    key: '_handleAppendInitSegment',
    value: function _handleAppendInitSegment() {
      this.state.initSegmentArrived = true;
      this.mse.addSourceBuffers();
    }
  }, {
    key: '_handleMediaSegment',
    value: function _handleMediaSegment() {
      this.mse.addSourceBuffers();
      this.mse.doAppend();
    }
  }, {
    key: '_handleSourceUpdateEnd',
    value: function _handleSourceUpdateEnd() {
      var time = this._player.currentTime;
      var video = this._player.video;
      var preloadTime = this._player.config.preloadTime || 5;

      var length = video.buffered.length;


      if (length === 0) {
        return;
      }

      var bufferEnd = video.buffered.end(length - 1);
      if (bufferEnd - time > preloadTime * 2 && !this._player.paused) {
        this._player.currentTime = bufferEnd - preloadTime;
      }
      this.mse.doAppend();
      if (this._player.paused) {
        this._handleTimeUpdate();
      }
    }
  }, {
    key: '_handleTimeUpdate',
    value: function _handleTimeUpdate() {
      var _this = this;

      var time = this._player.currentTime;

      var video = this._player.video;
      var buffered = video.buffered;

      if (!buffered || !buffered.length) {
        return;
      }

      var range = [0, 0];
      var currentTime = video.currentTime;
      if (buffered) {
        for (var i = 0, len = buffered.length; i < len; i++) {
          range[0] = buffered.start(i);
          range[1] = buffered.end(i);
          if (range[0] <= currentTime && currentTime <= range[1]) {
            break;
          }
        }
      }

      var bufferStart = range[0];
      var bufferEnd = range[1];

      if (currentTime < bufferStart) {
        video.currentTime = bufferStart;
        return;
      }

      if (time - bufferStart > 10 || buffered.length > 1) {
        // 在直播时及时清空buffer，降低直播内存占用
        if (this.bufferClearTimer || !this.state.randomAccessPoints.length) {
          return;
        }
        var rap = Infinity;
        for (var _i = 0; _i < this.state.randomAccessPoints.length; _i++) {
          var temp = Math.ceil(this.state.randomAccessPoints[_i] / 1000);
          if (temp > time - 10) {
            break;
          } else {
            rap = temp;
          }
        }

        // console.log('rap', rap, `time ${time}`, `bufferEnd ${bufferEnd}`,`clean ${Math.min(rap, time - 10, bufferEnd - 10)}`)
        this.mse.remove(Math.max(Math.min(rap - 1, time - 10, bufferEnd - 10), 0.1), 0);

        this.bufferClearTimer = setTimeout(function () {
          _this.bufferClearTimer = null;
        }, 5000);
      }
    }
  }, {
    key: '_handleNetworkError',
    value: function _handleNetworkError(tag, err) {
      this._player.emit('error', {
        code: err.code,
        errorType: 'network',
        ex: '[' + tag + ']: ' + err.message,
        errd: {}
      });
      this._onError(LOADER_EVENTS.LOADER_ERROR, tag, err, true);
    }
  }, {
    key: '_handleFetchRetry',
    value: function _handleFetchRetry(tag, info) {
      this._player.emit('retry', Object.assign({
        tag: tag
      }, info));
    }
  }, {
    key: '_handleDemuxError',
    value: function _handleDemuxError(tag, err, fatal) {
      if (fatal === undefined) {
        fatal = false;
      }
      this._player.emit('error', {
        errorType: 'parse',
        ex: '[' + tag + ']: ' + err.message,
        errd: {}
      });
      this._onError(DEMUX_EVENTS.DEMUX_ERROR, tag, err, fatal);
    }
  }, {
    key: '_handleMseError',
    value: function _handleMseError(tag, err, fatal) {
      if (fatal === undefined) {
        fatal = false;
      }
      this._onError(MSE_EVENTS.MSE_ERROR, tag, err, fatal);
    }
  }, {
    key: '_handleAddRAP',
    value: function _handleAddRAP(rap) {
      if (this.state.randomAccessPoints) {
        this.state.randomAccessPoints.push(rap);
      }
    }
  }, {
    key: '_onError',
    value: function _onError(type, mod, err, fatal) {
      var error = {
        errorType: type,
        errorDetails: '[' + mod + ']: ' + (err ? err.message : ''),
        errorFatal: fatal || false
      };
      this._player.emit(FLV_ERROR, error);
    }
  }, {
    key: 'seek',
    value: function seek() {
      if (!this.state.initSegmentArrived) {
        this.loadData();
      }
    }
  }, {
    key: 'loadData',
    value: function loadData() {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._player.config.url;

      var _ref = this._player.config.retry || {},
          times = _ref.count,
          delayTime = _ref.delay;

      this.emit(LOADER_EVENTS.LADER_START, url, {}, times, delayTime);
    }
  }, {
    key: 'pause',
    value: function pause() {
      var loader = this._context.getInstance('FETCH_LOADER');

      if (loader) {
        loader.cancel();
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._player.off('timeupdate', this._handleTimeUpdate);
      this.mse = null;
      this.state.randomAccessPoints = [];
    }
  }]);

  return FlvController;
}();

exports.default = FlvController;