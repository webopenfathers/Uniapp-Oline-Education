(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('xgplayer')) :
  typeof define === 'function' && define.amd ? define(['xgplayer'], factory) :
  (global = global || self, global.FlvLiveMobilePlayer = factory(global.Player));
}(this, (function (Player) { 'use strict';

  Player = Player && Object.prototype.hasOwnProperty.call(Player, 'default') ? Player['default'] : Player;

  var BROWSER_EVENTS = {
    VISIBILITY_CHANGE: 'VISIBILITY_CHANGE'
  };
  var PLAYER_EVENTS = {
    SEEK: 'SEEK'
  };

  var LOADER_EVENTS = {
    LADER_START: 'LOADER_START',
    LOADER_DATALOADED: 'LOADER_DATALOADED',
    LOADER_COMPLETE: 'LOADER_COMPLETE',
    LOADER_RESPONSE_HEADERS: 'LOADER_RESPONSE_HEADERS',
    LOADER_ERROR: 'LOADER_ERROR'
  };

  var DEMUX_EVENTS = {
    DEMUX_START: 'DEMUX_START',
    DEMUX_COMPLETE: 'DEMUX_COMPLETE',
    DEMUX_ERROR: 'DEMUX_ERROR',
    METADATA_PARSED: 'METADATA_PARSED',
    SEI_PARSED: 'SEI_PARSED',
    VIDEO_METADATA_CHANGE: 'VIDEO_METADATA_CHANGE',
    AUDIO_METADATA_CHANGE: 'AUDIO_METADATA_CHANGE',
    MEDIA_INFO: 'MEDIA_INFO'
  };

  var REMUX_EVENTS = {
    REMUX_METADATA: 'REMUX_METADATA',
    REMUX_MEDIA: 'REMUX_MEDIA',
    MEDIA_SEGMENT: 'MEDIA_SEGMENT',
    REMUX_ERROR: 'REMUX_ERROR',
    INIT_SEGMENT: 'INIT_SEGMENT',
    DETECT_CHANGE_STREAM: 'DETECT_CHANGE_STREAM',
    DETECT_CHANGE_STREAM_DISCONTINUE: 'DETECT_CHANGE_STREAM_DISCONTINUE',
    DETECT_AUDIO_GAP: 'DETECT_AUDIO_GAP',
    DETECT_AUDIO_OVERLAP: 'DETECT_AUDIO_OVERLAP',
    RANDOM_ACCESS_POINT: 'RANDOM_ACCESS_POINT'
  };

  var MSE_EVENTS = {
    SOURCE_UPDATE_END: 'SOURCE_UPDATE_END',
    MSE_ERROR: 'MSE_ERROR'

    // hls专有events
  };var HLS_EVENTS = {
    RETRY_TIME_EXCEEDED: 'RETRY_TIME_EXCEEDED'
  };

  var CRYTO_EVENTS = {
    START_DECRYPT: 'START_DECRYPT',
    DECRYPTED: 'DECRYPTED'
  };
  var ALLEVENTS = Object.assign({}, LOADER_EVENTS, DEMUX_EVENTS, REMUX_EVENTS, MSE_EVENTS, HLS_EVENTS, PLAYER_EVENTS, BROWSER_EVENTS);

  var FlvAllowedEvents = [];
  var HlsAllowedEvents = [];

  for (var key in ALLEVENTS) {
    if (ALLEVENTS.hasOwnProperty(key)) {
      FlvAllowedEvents.push(ALLEVENTS[key]);
    }
  }

  for (var _key in ALLEVENTS) {
    if (ALLEVENTS.hasOwnProperty(_key)) {
      HlsAllowedEvents.push(ALLEVENTS[_key]);
    }
  }

  var EVENTS = {
    ALLEVENTS: ALLEVENTS,
    HLS_EVENTS: HLS_EVENTS,
    REMUX_EVENTS: REMUX_EVENTS,
    DEMUX_EVENTS: DEMUX_EVENTS,
    MSE_EVENTS: MSE_EVENTS,
    LOADER_EVENTS: LOADER_EVENTS,
    FlvAllowedEvents: FlvAllowedEvents,
    HlsAllowedEvents: HlsAllowedEvents,
    CRYTO_EVENTS: CRYTO_EVENTS,
    PLAYER_EVENTS: PLAYER_EVENTS,
    BROWSER_EVENTS: BROWSER_EVENTS
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var isObjectFilled = function isObjectFilled(obj) {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (obj[key] === null) {
          return false;
        }
      }
    }
    return true;
  };

  var MediaInfo = function () {
    function MediaInfo() {
      _classCallCheck(this, MediaInfo);

      this.mimeType = null;
      this.duration = null;

      this.hasVideo = null;
      this.video = {
        codec: null,
        width: null,
        height: null,
        profile: null,
        level: null,
        frameRate: {
          fixed: true,
          fps: 25,
          fps_num: 25000,
          fps_den: 1000
        },
        chromaFormat: null,
        parRatio: {
          width: 1,
          height: 1
        }
      };

      this.hasAudio = null;

      this.audio = {
        codec: null,
        sampleRate: null,
        sampleRateIndex: null,
        channelCount: null
      };
    }

    _createClass(MediaInfo, [{
      key: "isComplete",
      value: function isComplete() {
        return MediaInfo.isBaseInfoReady(this) && MediaInfo.isVideoReady(this) && MediaInfo.isAudioReady(this);
      }
    }], [{
      key: "isBaseInfoReady",
      value: function isBaseInfoReady(mediaInfo) {
        return isObjectFilled(mediaInfo);
      }
    }, {
      key: "isVideoReady",
      value: function isVideoReady(mediaInfo) {
        if (!mediaInfo.hasVideo) {
          return true;
        }

        return isObjectFilled(mediaInfo.video);
      }
    }, {
      key: "isAudioReady",
      value: function isAudioReady(mediaInfo) {
        if (!mediaInfo.hasAudio) {
          return true;
        }

        return isObjectFilled(mediaInfo.video);
      }
    }]);

    return MediaInfo;
  }();

  var domain;

  // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).
  function EventHandlers() {}
  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }

  // nodejs oddity
  // require('events') === require('events').EventEmitter
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.usingDomains = false;

  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function () {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };

  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn) handler.call(self);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i) listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn) handler.call(self, arg1);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn) handler.call(self, arg1, arg2);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn) handler.call(self, arg1, arg2, arg3);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn) handler.apply(self, args);else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = type === 'error';

    events = this._events;
    if (events) doError = doError && events.error == null;else if (!doError) return false;

    domain = this.domain;

    // If there is no 'error' event listener then throw.
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er) er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }

    handler = events[type];

    if (!handler) return false;

    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++) args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');

    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }

      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }
  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;

    if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');

    events = this._events;
    if (!events) return this;

    list = events[type];
    if (!list) return this;

    if (list === listener || list.listener && list.listener === listener) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list[0] = undefined;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events[type];
        }
      } else {
        spliceOne(list, position);
      }

      if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events;

    events = this._events;
    if (!events) return this;

    // not listening for removeListener, no need to emit
    if (!events.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events[type]) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
      }
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      var keys = Object.keys(events);
      for (var i = 0, key; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      do {
        this.removeListener(type, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }

    return this;
  };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;

    if (!events) ret = [];else {
      evlistener = events[type];
      if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
    }

    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };

  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);
    while (i--) copy[i] = arr[i];
    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  };

  var _createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DIRECT_EMIT_FLAG = '__TO__';

  var Context = function () {
    function Context() {
      var allowedEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck$1(this, Context);

      this._emitter = new EventEmitter();
      if (!this._emitter.off) {
        this._emitter.off = this._emitter.removeListener;
      }

      this.mediaInfo = new MediaInfo();
      this._instanceMap = {}; // 所有的解码流程实例
      this._clsMap = {}; // 构造函数的map
      this._inited = false;
      this.allowedEvents = allowedEvents;
      this._hooks = {}; // 注册在事件前/后的钩子，例如 before('DEMUX_COMPLETE')
    }

    /**
     * 从上下文中获取解码流程实例，如果没有实例，构造一个
     * @param tag
     * @param args
     * @returns {*}
     */

    _createClass$1(Context, [{
      key: 'getInstance',
      value: function getInstance(tag) {
        var instance = this._instanceMap[tag];
        if (instance) {
          return instance;
        } else {
          // throw new Error(`${tag}实例尚未初始化`)
          return null;
        }
      }

      /**
       * 初始化具体实例
       * @param tag
       * @param args
       */

    }, {
      key: 'initInstance',
      value: function initInstance(tag) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var a = args[0],
            b = args[1],
            c = args[2],
            d = args[3];

        if (this._clsMap[tag]) {
          var newInstance = new this._clsMap[tag](a, b, c, d);
          this._instanceMap[tag] = newInstance;
          if (newInstance.init) {
            newInstance.init(); // TODO: lifecircle
          }
          return newInstance;
        } else {
          throw new Error(tag + "\u672A\u5728context\u4E2D\u6CE8\u518C");
        }
      }

      /**
       * 避免大量的initInstance调用，初始化所有的组件
       * @param config
       */

    }, {
      key: 'init',
      value: function init(config) {
        if (this._inited) {
          return;
        }
        for (var tag in this._clsMap) {
          // if not inited, init an instance
          if (this._clsMap.hasOwnProperty(tag) && !this._instanceMap[tag]) {
            this.initInstance(tag, config);
          }
        }
        this._inited = true;
      }

      /**
       * 注册一个上下文流程，提供安全的事件发送机制
       * @param tag
       * @param cls
       */

    }, {
      key: 'registry',
      value: function registry(tag, cls) {
        var _this2 = this;

        var emitter = this._emitter;
        var checkMessageName = this._isMessageNameValid.bind(this);
        var self = this;
        var enhanced = function (_cls) {
          _inherits(enhanced, _cls);

          function enhanced(a, b, c) {
            _classCallCheck$1(this, enhanced);

            var _this = _possibleConstructorReturn(this, (enhanced.__proto__ || Object.getPrototypeOf(enhanced)).call(this, a, b, c));

            _this.listeners = {};
            _this.onceListeners = {};
            _this.TAG = tag;
            _this._context = self;
            return _this;
          }

          _createClass$1(enhanced, [{
            key: 'on',
            value: function on(messageName, callback) {
              checkMessageName(messageName);

              if (this.listeners[messageName]) {
                this.listeners[messageName].push(callback);
              } else {
                this.listeners[messageName] = [callback];
              }

              emitter.on('' + messageName + DIRECT_EMIT_FLAG + tag, callback); // 建立定向通信监听
              return emitter.on(messageName, callback);
            }

            /**
             * 在某个事件触发前执行
             * @param messageName
             * @param callback
             */

          }, {
            key: 'before',
            value: function before(messageName, callback) {
              checkMessageName(messageName);
              if (self._hooks[messageName]) {
                self._hooks[messageName].push(callback);
              } else {
                self._hooks[messageName] = [callback];
              }
            }
          }, {
            key: 'once',
            value: function once(messageName, callback) {
              checkMessageName(messageName);

              if (this.onceListeners[messageName]) {
                this.onceListeners[messageName].push(callback);
              } else {
                this.onceListeners[messageName] = [callback];
              }

              emitter.once('' + messageName + DIRECT_EMIT_FLAG + tag, callback);
              return emitter.once(messageName, callback);
            }
          }, {
            key: 'emit',
            value: function emit(messageName) {
              checkMessageName(messageName);
              // console.log('emit ', messageName);

              var beforeList = self._hooks ? self._hooks[messageName] : null;

              if (beforeList) {
                for (var i = 0, len = beforeList.length; i < len; i++) {
                  var callback = beforeList[i];
                  callback();
                }
              }

              for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }

              return emitter.emit.apply(emitter, [messageName].concat(args));
            }

            /**
             * 定向发送给某个组件单例的消息
             * @param messageName
             * @param args
             */

          }, {
            key: 'emitTo',
            value: function emitTo(tag, messageName) {
              checkMessageName(messageName);

              for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                args[_key3 - 2] = arguments[_key3];
              }

              return emitter.emit.apply(emitter, ['' + messageName + DIRECT_EMIT_FLAG + tag].concat(args));
            }
          }, {
            key: 'off',
            value: function off(messageName, callback) {
              checkMessageName(messageName);
              return emitter.off(messageName, callback);
            }
          }, {
            key: 'removeListeners',
            value: function removeListeners() {
              var hasOwn = Object.prototype.hasOwnProperty.bind(this.listeners);

              for (var messageName in this.listeners) {
                if (hasOwn(messageName)) {
                  var callbacks = this.listeners[messageName] || [];
                  for (var i = 0; i < callbacks.length; i++) {
                    var callback = callbacks[i];
                    emitter.off(messageName, callback);
                    emitter.off('' + messageName + DIRECT_EMIT_FLAG + tag, callback);
                  }
                }
              }

              for (var _messageName in this.onceListeners) {
                if (hasOwn(_messageName)) {
                  var _callbacks = this.onceListeners[_messageName] || [];
                  for (var _i = 0; _i < _callbacks.length; _i++) {
                    var _callback = _callbacks[_i];
                    emitter.off(_messageName, _callback);
                    emitter.off('' + _messageName + DIRECT_EMIT_FLAG + tag, _callback);
                  }
                }
              }
            }

            /**
             * 在组件销毁时，默认将它注册的事件全部卸载，确保不会造成内存泄漏
             */

          }, {
            key: 'destroy',
            value: function destroy() {
              // step1 unlisten events
              this.removeListeners();
              this.listeners = {};

              // step2 release from context
              delete self._instanceMap[tag];
              if (_get(enhanced.prototype.__proto__ || Object.getPrototypeOf(enhanced.prototype), 'destroy', this)) {
                return _get(enhanced.prototype.__proto__ || Object.getPrototypeOf(enhanced.prototype), 'destroy', this).call(this);
              }
            }
          }]);

          return enhanced;
        }(cls);
        this._clsMap[tag] = enhanced;

        /**
         * get instance immediately
         * e.g const instance = context.registry(tag, Cls)(config)
         * */
        return function () {
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return _this2.initInstance.apply(_this2, [tag].concat(args));
        };
      }

      /**
       * 各个模块处理seek
       * @param time
       */

    }, {
      key: 'seek',
      value: function seek(time) {
        this._emitter.emit(EVENTS.PLAYER_EVENTS.SEEK, time);
      }

      /**
       * 对存在的实例进行
       */

    }, {
      key: 'destroyInstances',
      value: function destroyInstances() {
        var _this3 = this;

        Object.keys(this._instanceMap).forEach(function (tag) {
          if (_this3._instanceMap[tag].destroy) {
            _this3._instanceMap[tag].destroy();
          }
        });
      }

      /**
       * 编解码流程无需关注事件的解绑
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._emitter = null;
        this.allowedEvents = [];
        this._clsMap = null;
        this._context = null;
        this._hooks = null;
        this.destroyInstances();
      }

      /**
       * 对信道进行收拢
       * @param messageName
       * @private
       */

    }, {
      key: '_isMessageNameValid',
      value: function _isMessageNameValid(messageName) {
        if (!this.allowedEvents.indexOf(messageName) < 0) {
          throw new Error('unregistered message name: ' + messageName);
        }
      }
    }]);

    return Context;
  }();

  var _createClass$2 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Golomb = function () {
    function Golomb(uint8array) {
      _classCallCheck$2(this, Golomb);

      this.TAG = 'Golomb';
      this._buffer = uint8array;
      this._bufferIndex = 0;
      this._totalBytes = uint8array.byteLength;
      this._totalBits = uint8array.byteLength * 8;
      this._currentWord = 0;
      this._currentWordBitsLeft = 0;
    }

    _createClass$2(Golomb, [{
      key: 'destroy',
      value: function destroy() {
        this._buffer = null;
      }
    }, {
      key: '_fillCurrentWord',
      value: function _fillCurrentWord() {
        var bufferBytesLeft = this._totalBytes - this._bufferIndex;

        var bytesRead = Math.min(4, bufferBytesLeft);
        var word = new Uint8Array(4);
        word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
        this._currentWord = new DataView(word.buffer).getUint32(0);

        this._bufferIndex += bytesRead;
        this._currentWordBitsLeft = bytesRead * 8;
      }
    }, {
      key: 'readBits',
      value: function readBits(size) {
        var bits = Math.min(this._currentWordBitsLeft, size); // :uint
        var valu = this._currentWord >>> 32 - bits;
        if (size > 32) {
          throw new Error('Cannot read more than 32 bits at a time');
        }
        this._currentWordBitsLeft -= bits;
        if (this._currentWordBitsLeft > 0) {
          this._currentWord <<= bits;
        } else if (this._totalBytes - this._bufferIndex > 0) {
          this._fillCurrentWord();
        }

        bits = size - bits;
        if (bits > 0 && this._currentWordBitsLeft) {
          return valu << bits | this.readBits(bits);
        } else {
          return valu;
        }
      }
    }, {
      key: 'readBool',
      value: function readBool() {
        return this.readBits(1) === 1;
      }
    }, {
      key: 'readByte',
      value: function readByte() {
        return this.readBits(8);
      }
    }, {
      key: '_skipLeadingZero',
      value: function _skipLeadingZero() {
        var zeroCount = void 0;
        for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
          if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {
            this._currentWord <<= zeroCount;
            this._currentWordBitsLeft -= zeroCount;
            return zeroCount;
          }
        }
        this._fillCurrentWord();
        return zeroCount + this._skipLeadingZero();
      }
    }, {
      key: 'readUEG',
      value: function readUEG() {
        // unsigned exponential golomb
        var leadingZeros = this._skipLeadingZero();
        return this.readBits(leadingZeros + 1) - 1;
      }
    }, {
      key: 'readSEG',
      value: function readSEG() {
        // signed exponential golomb
        var value = this.readUEG();
        if (value & 0x01) {
          return value + 1 >>> 1;
        } else {
          return -1 * (value >>> 1);
        }
      }
    }]);

    return Golomb;
  }();

  var _createClass$3 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SPSParser = function () {
    function SPSParser() {
      _classCallCheck$3(this, SPSParser);
    }

    _createClass$3(SPSParser, null, [{
      key: '_ebsp2rbsp',
      value: function _ebsp2rbsp(uint8array) {
        var src = uint8array;
        var srcLength = src.byteLength;
        var dst = new Uint8Array(srcLength);
        var dstIdx = 0;

        for (var i = 0; i < srcLength; i++) {
          if (i >= 2) {
            if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
              continue;
            }
          }
          dst[dstIdx] = src[i];
          dstIdx++;
        }

        return new Uint8Array(dst.buffer, 0, dstIdx);
      }
    }, {
      key: 'parseSPS',
      value: function parseSPS(uint8array) {
        var rbsp = SPSParser._ebsp2rbsp(uint8array);
        var gb = new Golomb(rbsp);

        gb.readByte();
        var profileIdc = gb.readByte();
        gb.readByte();
        var levelIdc = gb.readByte();
        gb.readUEG();

        var profile_string = SPSParser.getProfileString(profileIdc);
        var level_string = SPSParser.getLevelString(levelIdc);
        var chroma_format_idc = 1;
        var chroma_format = 420;
        var chroma_format_table = [0, 420, 422, 444];
        var bit_depth = 8;

        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {
          chroma_format_idc = gb.readUEG();
          if (chroma_format_idc === 3) {
            gb.readBits(1);
          }
          if (chroma_format_idc <= 3) {
            chroma_format = chroma_format_table[chroma_format_idc];
          }

          bit_depth = gb.readUEG() + 8;
          gb.readUEG();
          gb.readBits(1);
          if (gb.readBool()) {
            var scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;
            for (var i = 0; i < scaling_list_count; i++) {
              if (gb.readBool()) {
                if (i < 6) {
                  SPSParser._skipScalingList(gb, 16);
                } else {
                  SPSParser._skipScalingList(gb, 64);
                }
              }
            }
          }
        }
        gb.readUEG();
        var pic_order_cnt_type = gb.readUEG();
        if (pic_order_cnt_type === 0) {
          gb.readUEG();
        } else if (pic_order_cnt_type === 1) {
          gb.readBits(1);
          gb.readSEG();
          gb.readSEG();
          var num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();
          for (var _i = 0; _i < num_ref_frames_in_pic_order_cnt_cycle; _i++) {
            gb.readSEG();
          }
        }
        gb.readUEG();
        gb.readBits(1);

        var pic_width_in_mbs_minus1 = gb.readUEG();
        var pic_height_in_map_units_minus1 = gb.readUEG();

        var frame_mbs_only_flag = gb.readBits(1);
        if (frame_mbs_only_flag === 0) {
          gb.readBits(1);
        }
        gb.readBits(1);

        var frame_crop_left_offset = 0;
        var frame_crop_right_offset = 0;
        var frame_crop_top_offset = 0;
        var frame_crop_bottom_offset = 0;

        var frame_cropping_flag = gb.readBool();
        if (frame_cropping_flag) {
          frame_crop_left_offset = gb.readUEG();
          frame_crop_right_offset = gb.readUEG();
          frame_crop_top_offset = gb.readUEG();
          frame_crop_bottom_offset = gb.readUEG();
        }

        var par_width = 1,
            par_height = 1;
        var fps = 0,
            fps_fixed = true,
            fps_num = 0,
            fps_den = 0;

        var vui_parameters_present_flag = gb.readBool();
        if (vui_parameters_present_flag) {
          if (gb.readBool()) {
            // aspect_ratio_info_present_flag
            var aspect_ratio_idc = gb.readByte();
            var par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];
            var par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];

            if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
              par_width = par_w_table[aspect_ratio_idc - 1];
              par_height = par_h_table[aspect_ratio_idc - 1];
            } else if (aspect_ratio_idc === 255) {
              par_width = gb.readByte() << 8 | gb.readByte();
              par_height = gb.readByte() << 8 | gb.readByte();
            }
          }

          if (gb.readBool()) {
            gb.readBool();
          }
          if (gb.readBool()) {
            gb.readBits(4);
            if (gb.readBool()) {
              gb.readBits(24);
            }
          }
          if (gb.readBool()) {
            gb.readUEG();
            gb.readUEG();
          }
          if (gb.readBool()) {
            var num_units_in_tick = gb.readBits(32);
            var time_scale = gb.readBits(32);
            fps_fixed = gb.readBool();

            fps_num = time_scale;
            fps_den = num_units_in_tick * 2;
            fps = fps_num / fps_den;
          }
        }

        var parScale = 1;
        if (par_width !== 1 || par_height !== 1) {
          parScale = par_width / par_height;
        }

        var crop_unit_x = 0,
            crop_unit_y = 0;
        if (chroma_format_idc === 0) {
          crop_unit_x = 1;
          crop_unit_y = 2 - frame_mbs_only_flag;
        } else {
          var sub_wc = chroma_format_idc === 3 ? 1 : 2;
          var sub_hc = chroma_format_idc === 1 ? 2 : 1;
          crop_unit_x = sub_wc;
          crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);
        }

        var codec_width = (pic_width_in_mbs_minus1 + 1) * 16;
        var codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);

        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;
        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;

        var present_width = Math.ceil(codec_width * parScale);

        gb.destroy();
        gb = null;

        return {
          profile_string: profile_string,
          level_string: level_string,
          bit_depth: bit_depth,
          chroma_format: chroma_format,
          chroma_format_string: SPSParser.getChromaFormatString(chroma_format),

          frame_rate: {
            fixed: fps_fixed,
            fps: fps,
            fps_den: fps_den,
            fps_num: fps_num
          },

          par_ratio: {
            width: par_width,
            height: par_height
          },

          codec_size: {
            width: codec_width,
            height: codec_height
          },

          present_size: {
            width: present_width,
            height: codec_height
          }
        };
      }
    }, {
      key: '_skipScalingList',
      value: function _skipScalingList(gb, count) {
        var lastScale = 8;
        var nextScale = 8;
        var deltaScale = 0;
        for (var i = 0; i < count; i++) {
          if (nextScale !== 0) {
            deltaScale = gb.readSEG();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      }
    }, {
      key: 'getProfileString',
      value: function getProfileString(profileIdc) {
        switch (profileIdc) {
          case 66:
            return 'Baseline';
          case 77:
            return 'Main';
          case 88:
            return 'Extended';
          case 100:
            return 'High';
          case 110:
            return 'High10';
          case 122:
            return 'High422';
          case 244:
            return 'High444';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'getLevelString',
      value: function getLevelString(levelIdc) {
        return (levelIdc / 10).toFixed(1);
      }
    }, {
      key: 'getChromaFormatString',
      value: function getChromaFormatString(chroma) {
        switch (chroma) {
          case 420:
            return '4:2:0';
          case 422:
            return '4:2:2';
          case 444:
            return '4:4:4';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'toVideoMeta',
      value: function toVideoMeta(spsConfig) {
        var meta = {};
        if (spsConfig && spsConfig.codec_size) {
          meta.codecWidth = spsConfig.codec_size.width;
          meta.codecHeight = spsConfig.codec_size.height;
          meta.presentWidth = spsConfig.present_size.width;
          meta.presentHeight = spsConfig.present_size.height;
        }

        meta.profile = spsConfig.profile_string;
        meta.level = spsConfig.level_string;
        meta.bitDepth = spsConfig.bit_depth;
        meta.chromaFormat = spsConfig.chroma_format;

        meta.parRatio = {
          width: spsConfig.par_ratio.width,
          height: spsConfig.par_ratio.height
        };

        meta.frameRate = spsConfig.frame_rate;

        var fpsDen = meta.frameRate.fps_den;
        var fpsNum = meta.frameRate.fps_num;
        meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum));
        return meta;
      }
    }]);

    return SPSParser;
  }();

  var _createClass$4 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var RBSP = function () {
    function RBSP() {
      _classCallCheck$4(this, RBSP);
    }

    _createClass$4(RBSP, null, [{
      key: "EBSP2RBSP",

      /**
       * convert EBSP to RBSP
       * @param data {Uint8Array}
       * @returns {Uint8Array}
       * @constructor
       */
      value: function EBSP2RBSP(data) {
        return data.filter(function (el, idx) {
          if (idx < 2) {
            return true;
          } else {
            return !(data[idx - 2] === 0 && data[idx - 1] === 0 && el === 3);
          }
        });
      }

      /**
       * @param data {Uint8Array}
       * @constructor
       */

    }, {
      key: "EBSP2SODB",
      value: function EBSP2SODB(data) {
        var lastByte = data[data.byteLength - 1];
        if (lastByte && lastByte === 128) {
          return data.slice(0, data.byteLength - 1);
        }

        return data;
      }
    }]);

    return RBSP;
  }();

  var _createClass$5 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var u8aToString = function u8aToString(data) {
    var result = '';
    for (var i = 0; i < data.byteLength; i++) {
      result += String.fromCharCode(data[i]);
    }
    return result;
  };

  var SEIParser = function () {
    function SEIParser() {
      _classCallCheck$5(this, SEIParser);
    }

    _createClass$5(SEIParser, null, [{
      key: '_resolveNalu',
      value: function _resolveNalu(data) {
        if (data.length >= 1) {
          return RBSP.EBSP2SODB(RBSP.EBSP2RBSP(data.slice(1)));
        }
        return null;
      }
      /**
       *
       * @param data {Uint8Array}
       */

    }, {
      key: 'parse',
      value: function parse(data) {
        var sodb = SEIParser._resolveNalu(data);

        var _SEIParser$switchPayl = SEIParser.switchPayloadType(sodb),
            payloadType = _SEIParser$switchPayl.payloadType,
            offset = _SEIParser$switchPayl.offset;

        var content = sodb.slice(offset);

        switch (payloadType) {
          case 5:
            return SEIParser.user_data_unregistered(content);
          default:
            return {
              code: payloadType,
              content: content
            };
        }
      }

      /**
       *
       * @param data
       * @returns {{payloadType: number, offset: number}}
       */

    }, {
      key: 'switchPayloadType',
      value: function switchPayloadType(data) {
        var dv = new DataView(data.buffer);
        var payloadType = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadType += 255;
        }
        payloadType += dv.getUint8(offset++);

        return {
          payloadType: payloadType,
          offset: offset
        };
      }

      /**
       *
       * @param data {Uint8Array}
       * @return {{ payloadLength: number, offset: number }}
       */

    }, {
      key: 'getPayloadLength',
      value: function getPayloadLength(data) {
        var dv = new DataView(data.buffer);

        var payloadLength = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadLength += 255;
        }
        payloadLength += dv.getUint8(offset++);

        return {
          payloadLength: payloadLength,
          offset: offset
        };
      }

      /**
       * resolve 0x05 user data unregistered
       * @param data {Uint8Array}
       */
      // eslint-disable-next-line camelcase

    }, {
      key: 'user_data_unregistered',
      value: function user_data_unregistered(data) {
        var _SEIParser$getPayload = SEIParser.getPayloadLength(data),
            payloadLength = _SEIParser$getPayload.payloadLength,
            offset = _SEIParser$getPayload.offset;

        if (payloadLength < 16) {
          return {
            uuid: '',
            content: null
          };
        }
        var payload = data.slice(offset);

        var uuid = u8aToString(payload.slice(0, 16));
        var content = u8aToString(payload.slice(16, payloadLength));

        return {
          code: 5, // for user data unregistered
          uuid: uuid,
          content: content
        };
      }
    }]);

    return SEIParser;
  }();

  var _createClass$6 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Nalunit = function () {
    function Nalunit() {
      _classCallCheck$6(this, Nalunit);
    }

    _createClass$6(Nalunit, null, [{
      key: 'getNalunits',
      value: function getNalunits(buffer) {
        if (buffer.length - buffer.position < 4) {
          return [];
        }

        var buf = buffer.dataview;
        var position = buffer.position;
        if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 3) === 1) {
          return Nalunit.getAnnexbNals(buffer);
        } else {
          return Nalunit.getAvccNals(buffer);
        }
      }
    }, {
      key: 'getAnnexbNals',
      value: function getAnnexbNals(buffer) {
        var nals = [];
        var position = Nalunit.getHeaderPositionAnnexB(buffer);
        var start = position.pos;
        var end = start;
        while (start < buffer.length - 4) {
          var header = buffer.buffer.slice(start, start + position.headerLength);
          if (position.pos === buffer.position) {
            buffer.skip(position.headerLength);
          }
          position = Nalunit.getHeaderPositionAnnexB(buffer);
          end = position.pos;
          var body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));
          var unit = { header: header, body: body };
          Nalunit.analyseNal(unit);
          if (unit.type <= 9 && unit.type !== 0) {
            nals.push(unit);
          }
          buffer.skip(end - buffer.position);
          start = end;
        }
        return nals;
      }
    }, {
      key: 'getAvccNals',
      value: function getAvccNals(buffer) {
        // buffer.buffer = RBSP.EBSP2RBSP(new Uint8Array(buffer.buffer)).buffer;
        // buffer.dataview = new DataView(buffer.buffer)
        // buffer.dataview.position = 0;
        var nals = [];
        while (buffer.position < buffer.length - 4) {
          var length = buffer.dataview.getInt32(buffer.dataview.position);
          if (buffer.length - buffer.position >= length) {
            var header = buffer.buffer.slice(buffer.position, buffer.position + 4);
            buffer.skip(4);
            var body = new Uint8Array(buffer.buffer.slice(buffer.position, buffer.position + length));
            buffer.skip(length);
            var unit = { header: header, body: body };
            Nalunit.analyseNal(unit);
            if (unit.type <= 9 && unit.type !== 0) {
              nals.push(unit);
            }
          } else {
            break;
          }
        }
        return nals;
      }
    }, {
      key: 'analyseNal',
      value: function analyseNal(unit) {
        var type = unit.body[0] & 0x1f;
        unit.type = type;
        switch (type) {
          case 1:
            // NDR
            unit.ndr = true;
            break;
          case 5:
            // IDR
            unit.idr = true;
            break;
          case 6:
            // SEI
            unit.sei = SEIParser.parse(unit.body);
            break;
          case 7:
            // SPS
            unit.sps = SPSParser.parseSPS(unit.body);
            break;
          case 8:
            // PPS
            unit.pps = true;
            break;
        }
      }
    }, {
      key: 'getHeaderPositionAnnexB',
      value: function getHeaderPositionAnnexB(buffer) {
        // seperate
        var pos = buffer.position;
        var headerLength = 0;
        var bufferLen = buffer.length;
        while (headerLength !== 3 && headerLength !== 4 && pos < bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            } else if (buffer.dataview.getInt8(pos + 2) === 1) {
              headerLength = 3;
            } else {
              pos++;
            }
          } else {
            pos++;
          }
        }

        if (pos === bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            }
          } else {
            pos++;
            if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {
              // 0x0000001
              headerLength = 3;
            } else {
              pos = bufferLen;
            }
          }
        }
        return { pos: pos, headerLength: headerLength };
      }
    }, {
      key: 'getAvcc',
      value: function getAvcc(sps, pps) {
        var ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);
        ret[0] = 0x01;
        ret[1] = sps[1];
        ret[2] = sps[2];
        ret[3] = sps[3];
        ret[4] = 255;
        ret[5] = 225;

        var offset = 6;

        ret.set(new Uint8Array([sps.byteLength >>> 8 & 0xff, sps.byteLength & 0xff]), offset);
        offset += 2;
        ret.set(sps, offset);
        offset += sps.byteLength;

        ret[offset] = 1;
        offset++;

        ret.set(new Uint8Array([pps.byteLength >>> 8 & 0xff, pps.byteLength & 0xff]), offset);
        offset += 2;
        ret.set(pps, offset);
        return ret;
      }
    }]);

    return Nalunit;
  }();

  var SpsParser = SPSParser;
  var NalUnit = Nalunit;

  var _createClass$7 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Golomb$1 = function () {
    function Golomb(uint8array) {
      _classCallCheck$7(this, Golomb);

      this.TAG = 'Golomb';
      this._buffer = uint8array;
      this._bufferIndex = 0;
      this._totalBytes = uint8array.byteLength;
      this._totalBits = uint8array.byteLength * 8;
      this._currentWord = 0;
      this._currentWordBitsLeft = 0;
    }

    _createClass$7(Golomb, [{
      key: 'destroy',
      value: function destroy() {
        this._buffer = null;
      }
    }, {
      key: '_fillCurrentWord',
      value: function _fillCurrentWord() {
        var bufferBytesLeft = this._totalBytes - this._bufferIndex;

        var bytesRead = Math.min(4, bufferBytesLeft);
        var word = new Uint8Array(4);
        word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
        this._currentWord = new DataView(word.buffer).getUint32(0);

        this._bufferIndex += bytesRead;
        this._currentWordBitsLeft = bytesRead * 8;
      }
    }, {
      key: 'readBits',
      value: function readBits(size) {
        var bits = Math.min(this._currentWordBitsLeft, size); // :uint
        var valu = this._currentWord >>> 32 - bits;
        if (size > 32) {
          throw new Error('Cannot read more than 32 bits at a time');
        }
        this._currentWordBitsLeft -= bits;
        if (this._currentWordBitsLeft > 0) {
          this._currentWord <<= bits;
        } else if (this._totalBytes - this._bufferIndex > 0) {
          this._fillCurrentWord();
        }

        bits = size - bits;
        if (bits > 0 && this._currentWordBitsLeft) {
          return valu << bits | this.readBits(bits);
        } else {
          return valu;
        }
      }
    }, {
      key: 'readBool',
      value: function readBool() {
        return this.readBits(1) === 1;
      }
    }, {
      key: 'readByte',
      value: function readByte() {
        return this.readBits(8);
      }
    }, {
      key: '_skipLeadingZero',
      value: function _skipLeadingZero() {
        if (this._currentWordBitsLeft === 0) {
          return 0;
        }
        var zeroCount = void 0;
        for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
          if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {
            this._currentWord <<= zeroCount;
            this._currentWordBitsLeft -= zeroCount;
            return zeroCount;
          }
        }
        this._fillCurrentWord();
        return zeroCount + this._skipLeadingZero();
      }
    }, {
      key: 'readUEG',
      value: function readUEG() {
        // unsigned exponential golomb
        var leadingZeros = this._skipLeadingZero();
        return this.readBits(leadingZeros + 1) - 1;
      }
    }, {
      key: 'readSEG',
      value: function readSEG() {
        // signed exponential golomb
        var value = this.readUEG();
        if (value & 0x01) {
          return value + 1 >>> 1;
        } else {
          return -1 * (value >>> 1);
        }
      }
    }]);

    return Golomb;
  }();

  var _createClass$8 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SPSParser$1 = function () {
    function SPSParser() {
      _classCallCheck$8(this, SPSParser);
    }

    _createClass$8(SPSParser, null, [{
      key: '_ebsp2rbsp',
      value: function _ebsp2rbsp(uint8array) {
        var src = uint8array;
        var srcLength = src.byteLength;
        var dst = new Uint8Array(srcLength);
        var dstIdx = 0;

        for (var i = 0; i < srcLength; i++) {
          if (i >= 2) {
            if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
              continue;
            }
          }
          dst[dstIdx] = src[i];
          dstIdx++;
        }

        return new Uint8Array(dst.buffer, 0, dstIdx);
      }
    }, {
      key: 'parseSPS',
      value: function parseSPS(uint8array) {
        var rbsp = SPSParser._ebsp2rbsp(uint8array);
        var gb = new Golomb$1(rbsp);

        var vpsId = 0,
            maxSubLayersMinus1 = 0,
            tINf = 0,
            spsId = 0,
            separate_colour_plane_flag = 0,
            chromaFormatIdc = 0,
            width = 0,
            height = 0,
            conf_win_left_offset = 0,
            conf_win_right_offset = 0,
            conf_win_top_offset = 0,
            conf_win_bottom_offset = 0,
            conformanceWindowFlag = 0,
            bitDepthLumaMinus8 = 0,
            bitDepthChromaMinus8 = 0,
            sub_width_c = 0,
            sub_height_c = 0,
            profileTierLevel = {};

        gb.readByte(); // NAL header
        gb.readByte();

        vpsId = gb.readBits(4); // vps_id
        maxSubLayersMinus1 = gb.readBits(3); // max_sub_layers_minus1
        tINf = gb.readBits(1); // temporal_id_nesting_flag

        profileTierLevel = SPSParser._readProfileTierLevel(gb, maxSubLayersMinus1);

        spsId = gb.readUEG(); // sps id
        chromaFormatIdc = gb.readUEG();
        if (chromaFormatIdc === 3) {
          separate_colour_plane_flag = gb.readBits(1); // separate_colour_plane_flag
        }

        width = gb.readUEG(); // pic_width_in_luma_samples
        height = gb.readUEG(); // pic_height_in_luma_samples

        conformanceWindowFlag = gb.readBits(1);
        if (conformanceWindowFlag === 1) {
          conf_win_left_offset = gb.readUEG(); // conf_win_left_offset
          conf_win_right_offset = gb.readUEG(); // conf_win_right_offset
          conf_win_top_offset = gb.readUEG(); // conf_win_top_offset
          conf_win_bottom_offset = gb.readUEG(); // conf_win_bottom_offset
        }

        bitDepthLumaMinus8 = gb.readUEG(); // bit_depth_luma_minus8
        bitDepthChromaMinus8 = gb.readUEG(); // bit_depth_chroma_minus8

        if (conformanceWindowFlag === 1) {
          sub_width_c = (1 === chromaFormatIdc || 2 === chromaFormatIdc) && 0 === separate_colour_plane_flag ? 2 : 1;
          sub_height_c = 1 === chromaFormatIdc && 0 === separate_colour_plane_flag ? 2 : 1;
          width -= sub_width_c * conf_win_right_offset + sub_width_c * conf_win_left_offset;
          height -= sub_height_c * conf_win_bottom_offset + sub_height_c * conf_win_top_offset;
        }

        gb.destroy();
        gb = null;

        return { width: width, height: height,
          general_profile_space: profileTierLevel.general_profile_space,
          general_tier_flag: profileTierLevel.general_tier_flag,
          general_profile_idc: profileTierLevel.general_profile_idc,
          general_level_idc: profileTierLevel.general_level_idc,
          chromaFormatIdc: chromaFormatIdc,
          bitDepthLumaMinus8: bitDepthLumaMinus8,
          bitDepthChromaMinus8: bitDepthChromaMinus8 };
      }

      // static parseSPS (uint8array) {
      //   let rbsp = SPSParser._ebsp2rbsp(uint8array)
      //   let gb = new Golomb(rbsp)
      //
      //   gb.readByte()
      //   let profileIdc = gb.readByte()
      //   gb.readByte()
      //   let levelIdc = gb.readByte()
      //   gb.readUEG()
      //
      //   let profile_string = SPSParser.getProfileString(profileIdc)
      //   let level_string = SPSParser.getLevelString(levelIdc)
      //   let chroma_format_idc = 1
      //   let chroma_format = 420
      //   let chroma_format_table = [0, 420, 422, 444]
      //   let bit_depth = 8
      //
      //   if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 ||
      //     profileIdc === 244 || profileIdc === 44 || profileIdc === 83 ||
      //     profileIdc === 86 || profileIdc === 118 || profileIdc === 128 ||
      //     profileIdc === 138 || profileIdc === 144) {
      //     chroma_format_idc = gb.readUEG()
      //     if (chroma_format_idc === 3) {
      //       gb.readBits(1)
      //     }
      //     if (chroma_format_idc <= 3) {
      //       chroma_format = chroma_format_table[chroma_format_idc]
      //     }
      //
      //     bit_depth = gb.readUEG() + 8
      //     gb.readUEG()
      //     gb.readBits(1)
      //     if (gb.readBool()) {
      //       let scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12
      //       for (let i = 0; i < scaling_list_count; i++) {
      //         if (gb.readBool()) {
      //           if (i < 6) {
      //             SPSParser._skipScalingList(gb, 16)
      //           } else {
      //             SPSParser._skipScalingList(gb, 64)
      //           }
      //         }
      //       }
      //     }
      //   }
      //   gb.readUEG()
      //   let pic_order_cnt_type = gb.readUEG()
      //   if (pic_order_cnt_type === 0) {
      //     gb.readUEG()
      //   } else if (pic_order_cnt_type === 1) {
      //     gb.readBits(1)
      //     gb.readSEG()
      //     gb.readSEG()
      //     let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG()
      //     for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {
      //       gb.readSEG()
      //     }
      //   }
      //   gb.readUEG()
      //   gb.readBits(1)
      //
      //   let pic_width_in_mbs_minus1 = gb.readUEG()
      //   let pic_height_in_map_units_minus1 = gb.readUEG()
      //
      //   let frame_mbs_only_flag = gb.readBits(1)
      //   if (frame_mbs_only_flag === 0) {
      //     gb.readBits(1)
      //   }
      //   gb.readBits(1)
      //
      //   let frame_crop_left_offset = 0
      //   let frame_crop_right_offset = 0
      //   let frame_crop_top_offset = 0
      //   let frame_crop_bottom_offset = 0
      //
      //   let frame_cropping_flag = gb.readBool()
      //   if (frame_cropping_flag) {
      //     frame_crop_left_offset = gb.readUEG()
      //     frame_crop_right_offset = gb.readUEG()
      //     frame_crop_top_offset = gb.readUEG()
      //     frame_crop_bottom_offset = gb.readUEG()
      //   }
      //
      //   let par_width = 1, par_height = 1
      //   let fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0
      //
      //   let vui_parameters_present_flag = gb.readBool()
      //   if (vui_parameters_present_flag) {
      //     if (gb.readBool()) { // aspect_ratio_info_present_flag
      //       let aspect_ratio_idc = gb.readByte()
      //       let par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2]
      //       let par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1]
      //
      //       if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
      //         par_width = par_w_table[aspect_ratio_idc - 1]
      //         par_height = par_h_table[aspect_ratio_idc - 1]
      //       } else if (aspect_ratio_idc === 255) {
      //         par_width = gb.readByte() << 8 | gb.readByte()
      //         par_height = gb.readByte() << 8 | gb.readByte()
      //       }
      //     }
      //
      //     if (gb.readBool()) {
      //       gb.readBool()
      //     }
      //     if (gb.readBool()) {
      //       gb.readBits(4)
      //       if (gb.readBool()) {
      //         gb.readBits(24)
      //       }
      //     }
      //     if (gb.readBool()) {
      //       gb.readUEG()
      //       gb.readUEG()
      //     }
      //     if (gb.readBool()) {
      //       let num_units_in_tick = gb.readBits(32)
      //       let time_scale = gb.readBits(32)
      //       fps_fixed = gb.readBool()
      //
      //       fps_num = time_scale
      //       fps_den = num_units_in_tick * 2
      //       fps = fps_num / fps_den
      //     }
      //   }
      //
      //   let parScale = 1
      //   if (par_width !== 1 || par_height !== 1) {
      //     parScale = par_width / par_height
      //   }
      //
      //   let crop_unit_x = 0, crop_unit_y = 0
      //   if (chroma_format_idc === 0) {
      //     crop_unit_x = 1
      //     crop_unit_y = 2 - frame_mbs_only_flag
      //   } else {
      //     let sub_wc = (chroma_format_idc === 3) ? 1 : 2
      //     let sub_hc = (chroma_format_idc === 1) ? 2 : 1
      //     crop_unit_x = sub_wc
      //     crop_unit_y = sub_hc * (2 - frame_mbs_only_flag)
      //   }
      //
      //   let codec_width = (pic_width_in_mbs_minus1 + 1) * 16
      //   let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16)
      //
      //   codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x
      //   codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y
      //
      //   let present_width = Math.ceil(codec_width * parScale)
      //
      //   gb.destroy()
      //   gb = null
      //
      //   return {
      //     profile_string: profile_string,
      //     level_string: level_string,
      //     bit_depth: bit_depth,
      //     chroma_format: chroma_format,
      //     chroma_format_string: SPSParser.getChromaFormatString(chroma_format),
      //
      //     frame_rate: {
      //       fixed: fps_fixed,
      //       fps: fps,
      //       fps_den: fps_den,
      //       fps_num: fps_num
      //     },
      //
      //     par_ratio: {
      //       width: par_width,
      //       height: par_height
      //     },
      //
      //     codec_size: {
      //       width: codec_width,
      //       height: codec_height
      //     },
      //
      //     present_size: {
      //       width: present_width,
      //       height: codec_height
      //     }
      //   }
      // }

    }, {
      key: '_readProfileTierLevel',
      value: function _readProfileTierLevel(gb, maxSubLayersMinus1) {
        var general_profile_space = 0;
        var general_tier_flag = 0;
        var general_profile_idc = 0;
        var general_level_idc = 0;
        general_profile_space = gb.readBits(2) || 0; // profile_space
        general_tier_flag = gb.readBits(1) || 0; // tierFlag
        general_profile_idc = gb.readBits(5) || 0; // profileIdc

        gb.readBits(16); // some 32bits
        gb.readBits(16);

        gb.readBits(1); // progressiveSourceFlag
        gb.readBits(1); // interlacedSourceFlag
        gb.readBits(1); // nonPackedConstraintFlag
        gb.readBits(1); // frameOnlyConstraintFlag


        gb.readBits(16); // reserved zero bits
        gb.readBits(16);
        gb.readBits(12);

        general_level_idc = gb.readBits(8) || 0; // level_idc

        var subLayerProfilePresentFlag = [];
        var subLayerLevelPresentFlag = [];
        for (var j = 0; j < maxSubLayersMinus1; j++) {
          subLayerProfilePresentFlag[j] = gb.readBits(1);
          subLayerLevelPresentFlag[j] = gb.readBits(1);
        }

        if (maxSubLayersMinus1 > 0) {
          gb.readBits((8 - maxSubLayersMinus1) * 2);
        }

        for (var i = 0; i < maxSubLayersMinus1; i++) {
          if (subLayerProfilePresentFlag[i] !== 0) {
            gb.readBits(2);
            gb.readBits(1);
            gb.readBits(5);

            gb.readBits(16);
            gb.readBits(16);

            gb.readBits(4);

            gb.readBits(16);
            gb.readBits(16);
            gb.readBits(12);
          }
          if (subLayerLevelPresentFlag[i] !== 0) {
            gb.readBits(8);
          }
        }

        return {
          general_profile_space: general_profile_space,
          general_tier_flag: general_tier_flag,
          general_profile_idc: general_profile_idc,
          general_level_idc: general_level_idc
        };
      }
    }, {
      key: '_skipScalingList',
      value: function _skipScalingList(gb, count) {
        var lastScale = 8;
        var nextScale = 8;
        var deltaScale = 0;
        for (var i = 0; i < count; i++) {
          if (nextScale !== 0) {
            deltaScale = gb.readSEG();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      }
    }, {
      key: 'getProfileString',
      value: function getProfileString(profileIdc) {
        switch (profileIdc) {
          case 66:
            return 'Baseline';
          case 77:
            return 'Main';
          case 88:
            return 'Extended';
          case 100:
            return 'High';
          case 110:
            return 'High10';
          case 122:
            return 'High422';
          case 244:
            return 'High444';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'getLevelString',
      value: function getLevelString(levelIdc) {
        return (levelIdc / 10).toFixed(1);
      }
    }, {
      key: 'getChromaFormatString',
      value: function getChromaFormatString(chroma) {
        switch (chroma) {
          case 420:
            return '4:2:0';
          case 422:
            return '4:2:2';
          case 444:
            return '4:4:4';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'toVideoMeta',
      value: function toVideoMeta(spsConfig) {
        var meta = {};
        if (spsConfig) {
          meta.codecWidth = spsConfig.width;
          meta.codecHeight = spsConfig.height;
          meta.presentWidth = spsConfig.width;
          meta.presentHeight = spsConfig.height;
        }

        meta.profile = spsConfig.profile_string;
        meta.level = spsConfig.level_string;
        meta.bitDepth = spsConfig.bit_depth;
        meta.chromaFormat = spsConfig.chroma_format;

        // meta.parRatio = {
        //   width: spsConfig.par_ratio.width,
        //   height: spsConfig.par_ratio.height
        // }

        // meta.frameRate = spsConfig.frame_rate

        // let fpsDen = meta.frameRate.fps_den
        // let fpsNum = meta.frameRate.fps_num
        // meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum))
        return meta;
      }
    }]);

    return SPSParser;
  }();

  var _createClass$9 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var RBSP$1 = function () {
    function RBSP() {
      _classCallCheck$9(this, RBSP);
    }

    _createClass$9(RBSP, null, [{
      key: "EBSP2RBSP",

      /**
       * convert EBSP to RBSP
       * @param data {Uint8Array}
       * @returns {Uint8Array}
       * @constructor
       */
      value: function EBSP2RBSP(data) {
        return data.filter(function (el, idx) {
          if (idx < 2) {
            return true;
          } else {
            return !(data[idx - 2] === 0 && data[idx - 1] === 0 && el === 3);
          }
        });
      }

      /**
       * @param data {Uint8Array}
       * @constructor
       */

    }, {
      key: "EBSP2SODB",
      value: function EBSP2SODB(data) {
        var lastByte = data[data.byteLength - 1];
        if (lastByte && lastByte === 128) {
          return data.slice(0, data.byteLength - 1);
        }

        return data;
      }
    }]);

    return RBSP;
  }();

  var _createClass$a = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$a(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var u8aToString$1 = function u8aToString(data) {
    var result = '';
    for (var i = 0; i < data.byteLength; i++) {
      result += String.fromCharCode(data[i]);
    }
    return result;
  };

  var SEIParser$1 = function () {
    function SEIParser() {
      _classCallCheck$a(this, SEIParser);
    }

    _createClass$a(SEIParser, null, [{
      key: '_resolveNalu',
      value: function _resolveNalu(data) {
        if (data.length >= 1) {
          return RBSP$1.EBSP2SODB(RBSP$1.EBSP2RBSP(data.slice(1)));
        }
        return null;
      }
      /**
       *
       * @param data {Uint8Array}
       */

    }, {
      key: 'parse',
      value: function parse(data) {
        var sodb = SEIParser._resolveNalu(data);

        var _SEIParser$switchPayl = SEIParser.switchPayloadType(sodb),
            payloadType = _SEIParser$switchPayl.payloadType,
            offset = _SEIParser$switchPayl.offset;

        var content = sodb.slice(offset);

        switch (payloadType) {
          case 5:
            return SEIParser.user_data_unregistered(content);
          default:
            return {
              code: payloadType,
              content: content
            };
        }
      }

      /**
       *
       * @param data
       * @returns {{payloadType: number, offset: number}}
       */

    }, {
      key: 'switchPayloadType',
      value: function switchPayloadType(data) {
        var dv = new DataView(data.buffer);
        var payloadType = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadType += 255;
        }
        payloadType += dv.getUint8(offset++);

        return {
          payloadType: payloadType,
          offset: offset
        };
      }

      /**
       *
       * @param data {Uint8Array}
       * @return {{ payloadLength: number, offset: number }}
       */

    }, {
      key: 'getPayloadLength',
      value: function getPayloadLength(data) {
        var dv = new DataView(data.buffer);

        var payloadLength = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadLength += 255;
        }
        payloadLength += dv.getUint8(offset++);

        return {
          payloadLength: payloadLength,
          offset: offset
        };
      }

      /**
       * resolve 0x05 user data unregistered
       * @param data {Uint8Array}
       */
      // eslint-disable-next-line camelcase

    }, {
      key: 'user_data_unregistered',
      value: function user_data_unregistered(data) {
        var _SEIParser$getPayload = SEIParser.getPayloadLength(data),
            payloadLength = _SEIParser$getPayload.payloadLength,
            offset = _SEIParser$getPayload.offset;

        if (payloadLength < 16) {
          return {
            uuid: '',
            content: null
          };
        }
        var payload = data.slice(offset);

        var uuid = u8aToString$1(payload.slice(0, 16));
        var content = u8aToString$1(payload.slice(16, payloadLength));

        return {
          code: 5, // for user data unregistered
          uuid: uuid,
          content: content
        };
      }
    }]);

    return SEIParser;
  }();

  var _createClass$b = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$b(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Nalunit$1 = function () {
    function Nalunit() {
      _classCallCheck$b(this, Nalunit);
    }

    _createClass$b(Nalunit, null, [{
      key: 'getNalunits',
      value: function getNalunits(buffer) {
        if (buffer.length - buffer.position < 4) {
          return [];
        }

        var buf = buffer.dataview;
        var position = buffer.position;
        // console.log('getNalunits')
        // console.log('buf: ', buf)
        // console.log(buf.getInt8(position))
        // console.log(buf.getInt8(position+1))
        // console.log(buf.getInt8(position+2))
        // console.log(buf.getInt8(position+3))
        if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {
          return Nalunit.getAnnexbNals(buffer);
        } else {
          return Nalunit.getHvccNals(buffer);
        }
      }
    }, {
      key: 'getAnnexbNals',
      value: function getAnnexbNals(buffer) {
        // console.log('getAnnexbNals')
        // console.log('buffer: ', buffer)
        var nals = [];
        var position = Nalunit.getHeaderPositionAnnexB(buffer);
        var start = position.pos;
        var end = start;
        while (start < buffer.length - 4) {
          var header = buffer.buffer.slice(start, start + position.headerLength);
          if (position.pos === buffer.position) {
            buffer.skip(position.headerLength);
          }
          position = Nalunit.getHeaderPositionAnnexB(buffer);
          end = position.pos;
          var body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));
          var unit = { header: header, body: body };
          Nalunit.analyseNal(unit);
          if (unit.type <= 40) {
            nals.push(unit);
          }
          buffer.skip(end - buffer.position);
          start = end;
        }
        return nals;
      }
    }, {
      key: 'getHvccNals',
      value: function getHvccNals(buffer) {
        // console.log('getHvccNals')
        var nals = [];
        while (buffer.position < buffer.length - 4) {
          // console.log('buffer')
          // console.log(buffer)
          // console.log(buffer.position)
          // console.log(buffer.length)
          // console.log(buffer.dataview)
          // let length = buffer.dataview.getInt32();
          var length = buffer.dataview.getInt32(buffer.dataview.position);
          if (buffer.length - buffer.position >= length) {
            var header = buffer.buffer.slice(buffer.position, buffer.position + 4);
            buffer.skip(4);
            var body = new Uint8Array(buffer.buffer.slice(buffer.position, buffer.position + length));
            buffer.skip(length);
            var unit = { header: header, body: body };
            try {
              Nalunit.analyseNal(unit);
            } catch (error) {
              continue;
            }
            if (unit.type <= 40) {
              nals.push(unit);
            }
          } else {
            break;
          }
        }
        return nals;
      }
    }, {
      key: 'analyseNal',
      value: function analyseNal(unit) {
        // console.log('analyseNal')
        // console.log('unit: ', unit)
        // console.log(unit.body[0] >>> 1)
        var type = unit.body[0] >>> 1 & 0x3f;
        // console.log('type: ', type)
        unit.type = type;
        switch (type) {
          case 0:
            // SLICE_TRAIL_N
            unit.slice_trail_n = true;
            break;
          case 1:
            // SLICE_TRAIL_R
            unit.slice_trail_r = true;
            unit.key = true;
            break;
          case 2:
            // SLICE_TSA_N
            unit.slice_tsa_n = true;
            break;
          case 3:
            // SLICE_TSA_R
            unit.slice_tsa_r = true;
            unit.key = true;
            break;
          case 4:
            // SLICE_STSA_N
            unit.slice_stsa_n = true;
            break;
          case 5:
            // SLICE_STSA_R
            unit.slice_stsa_r = true;
            unit.key = true;
            break;
          case 6:
            // SLICE_RADL_N
            unit.slice_radl_n = true;
            break;
          case 7:
            // SLICE_RADL_R
            unit.slice_radl_r = true;
            unit.key = true;
            break;
          case 8:
            // SLICE_RASL_N
            unit.slice_rasl_n = true;
            break;
          case 9:
            // SLICE_RASL_R
            unit.slice_rasl_r = true;
            unit.key = true;
            break;
          case 16:
            // SLICE_BLA_W_LP
            unit.slice_bla_w_lp = true;
            break;
          case 17:
            // SLICE_BLA_W_RADL
            unit.slice_bla_w_radl = true;
            break;
          case 18:
            // SLICE_BLA_N_LP
            unit.slice_bla_n_lp = true;
            break;
          case 19:
            // SLICE_IDR_W_RADL
            unit.slice_idl_w_radl = true;
            unit.key = true;
            break;
          case 20:
            // SLICE_IDR_N_LP
            unit.slice_idr_n_lp = true;
            unit.key = true;
            break;
          case 21:
            // SLICE_CRA_NUT
            unit.slice_cra_nut = true;
            unit.key = true;
            break;
          case 32:
            // VPS
            unit.vps = true;
            break;
          case 33:
            // SPS
            unit.sps = SPSParser$1.parseSPS(unit.body);
            break;
          case 34:
            // PPS
            unit.pps = true;
            break;
          case 35:
            // AUD
            break;
          case 36:
            // EOS
            unit.aud = true;
            break;
          case 37:
            // EOB
            unit.eob = true;
            break;
          case 38:
            // FD
            unit.fd = true;
            break;
          case 39:
            // PREFIX_SEI
            // unit.prefix_sei = true;
            unit.sei = SEIParser$1.parse(unit.body.slice(1));
            break;
          case 40:
            // SUFFIX_SEI
            unit.sei = SEIParser$1.parse(unit.body.slice(1));
            break;
          // case 1:
          //   // NDR
          //   unit.ndr = true;
          //   break;
          // case 5:
          //   // IDR
          //   unit.idr = true;
          //   break;
          // case 6:
          //   // SEI
          //   break;
          // case 7:
          //   // SPS
          //   unit.sps = SpsParser.parseSPS(unit.body);
          //   break;
          // case 8:
          //   // PPS
          //   unit.pps = true;
          //   break;
          // case 9:
          //   // AUD
          //   break;
          // default:
          //   break;
        }
      }
    }, {
      key: 'getHeaderPositionAnnexB',
      value: function getHeaderPositionAnnexB(buffer) {
        // seperate
        var pos = buffer.position;
        var headerLength = 0;
        var bufferLen = buffer.length;
        while (headerLength !== 3 && headerLength !== 4 && pos < bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            } else if (buffer.dataview.getInt8(pos + 2) === 1) {
              headerLength = 3;
            } else {
              pos++;
            }
          } else {
            pos++;
          }
        }

        if (pos === bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            }
          } else {
            pos++;
            if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {
              // 0x0000001
              headerLength = 3;
            } else {
              pos = bufferLen;
            }
          }
        }
        return { pos: pos, headerLength: headerLength };
      }

      // static getAvcc (sps, pps) {
      //   let ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);
      //   ret[0] = 0x01;
      //   ret[1] = sps[1];
      //   ret[2] = sps[2];
      //   ret[3] = sps[3];
      //   ret[4] = 255;
      //   ret[5] = 225;
      //
      //   let offset = 6;
      //
      //   ret.set(new Uint8Array([(sps.byteLength >>> 8) & 0xff, sps.byteLength & 0xff]), offset);
      //   offset += 2;
      //   ret.set(sps, offset);
      //   offset += sps.byteLength;
      //
      //   ret[offset] = 1;
      //   offset++;
      //
      //   ret.set(new Uint8Array([(pps.byteLength >>> 8) & 0xff, pps.byteLength & 0xff]), offset);
      //   offset += 2;
      //   ret.set(pps, offset);
      //   return ret;
      // }

    }]);

    return Nalunit;
  }();

  var NalUnitHEVC = Nalunit$1;

  var _createClass$c = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$c(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Stream = function () {
    function Stream(buffer) {
      _classCallCheck$c(this, Stream);

      if (buffer instanceof ArrayBuffer) {
        this.buffer = buffer;
        this.dataview = new DataView(buffer);
        this.dataview.position = 0;
      } else {
        throw new Error('data is invalid');
      }
    }

    _createClass$c(Stream, [{
      key: 'back',
      value: function back(count) {
        this.position -= count;
      }
    }, {
      key: 'skip',
      value: function skip(count) {
        var loop = Math.floor(count / 4);
        var last = count % 4;
        for (var i = 0; i < loop; i++) {
          Stream.readByte(this.dataview, 4);
        }
        if (last > 0) {
          Stream.readByte(this.dataview, last);
        }
      }

      /**
       * [readByte 从DataView中读取数据]
       * @param  {DataView} buffer [DataView实例]
       * @param  {Number} size   [读取字节数]
       * @return {Number}        [整数]
       */

    }, {
      key: 'readUint8',
      value: function readUint8() {
        return Stream.readByte(this.dataview, 1);
      }
    }, {
      key: 'readUint16',
      value: function readUint16() {
        return Stream.readByte(this.dataview, 2);
      }
    }, {
      key: 'readUint24',
      value: function readUint24() {
        return Stream.readByte(this.dataview, 3);
      }
    }, {
      key: 'readUint32',
      value: function readUint32() {
        return Stream.readByte(this.dataview, 4);
      }
    }, {
      key: 'readUint64',
      value: function readUint64() {
        return Stream.readByte(this.dataview, 8);
      }
    }, {
      key: 'readInt8',
      value: function readInt8() {
        return Stream.readByte(this.dataview, 1, true);
      }
    }, {
      key: 'readInt16',
      value: function readInt16() {
        return Stream.readByte(this.dataview, 2, true);
      }
    }, {
      key: 'readInt32',
      value: function readInt32() {
        return Stream.readByte(this.dataview, 4, true);
      }
    }, {
      key: 'writeUint32',
      value: function writeUint32(value) {
        return new Uint8Array([value >>> 24 & 0xff, value >>> 16 & 0xff, value >>> 8 & 0xff, value & 0xff]);
      }
    }, {
      key: 'length',
      get: function get() {
        return this.buffer.byteLength;
      }
    }, {
      key: 'position',
      set: function set(value) {
        this.dataview.position = value;
      },
      get: function get() {
        return this.dataview.position;
      }
    }], [{
      key: 'readByte',
      value: function readByte(buffer, size, sign) {
        var res = void 0;
        switch (size) {
          case 1:
            if (sign) {
              res = buffer.getInt8(buffer.position);
            } else {
              res = buffer.getUint8(buffer.position);
            }
            break;
          case 2:
            if (sign) {
              res = buffer.getInt16(buffer.position);
            } else {
              res = buffer.getUint16(buffer.position);
            }
            break;
          case 3:
            if (sign) {
              throw new Error('not supported for readByte 3');
            } else {
              res = buffer.getUint8(buffer.position) << 16;
              res |= buffer.getUint8(buffer.position + 1) << 8;
              res |= buffer.getUint8(buffer.position + 2);
            }
            break;
          case 4:
            if (sign) {
              res = buffer.getInt32(buffer.position);
            } else {
              res = buffer.getUint32(buffer.position);
            }
            break;
          case 8:
            if (sign) {
              throw new Error('not supported for readBody 8');
            } else {
              res = buffer.getUint32(buffer.position) << 32;
              res |= buffer.getUint32(buffer.position + 4);
            }
            break;
          default:
            res = '';
        }
        buffer.position += size;
        return res;
      }
    }]);

    return Stream;
  }();

  var _createClass$d = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var DEMUX_EVENTS$1 = EVENTS.DEMUX_EVENTS;
  var LOADER_EVENTS$1 = EVENTS.LOADER_EVENTS;

  var Tag = 'FLVController';

  var FLV_ERROR = 'FLV_ERROR';

  var FlvController = function () {
    function FlvController(player) {
      _classCallCheck$d(this, FlvController);

      this.TAG = Tag;
      this._player = player;
      this.state = {
        initSegmentArrived: false,
        randomAccessPoints: []
      };

      this.bufferClearTimer = null;
    }

    _createClass$d(FlvController, [{
      key: 'init',
      value: function init() {
        this.initComponents();
        this.initListeners();
      }
    }, {
      key: 'initComponents',
      value: function initComponents() {
        var _player$config = this._player.config,
            FetchLoader = _player$config.FetchLoader,
            XgBuffer = _player$config.XgBuffer,
            FlvDemuxer = _player$config.FlvDemuxer,
            Tracks = _player$config.Tracks,
            Logger = _player$config.Logger;

        this._context.registry('FETCH_LOADER', FetchLoader);
        this._context.registry('LOADER_BUFFER', XgBuffer);

        this._context.registry('FLV_DEMUXER', FlvDemuxer);
        this._context.registry('TRACKS', Tracks);

        this._context.registry('LOGGER', Logger);
        // this._context.registry('PAGE_VISIBILITY', PageVisibility)
      }
    }, {
      key: 'initListeners',
      value: function initListeners() {
        this.on(LOADER_EVENTS$1.LOADER_DATALOADED, this._handleLoaderDataLoaded.bind(this));
        this.on(LOADER_EVENTS$1.LOADER_ERROR, this._handleNetworkError.bind(this));

        this.on(DEMUX_EVENTS$1.MEDIA_INFO, this._handleMediaInfo.bind(this));
        this.on(DEMUX_EVENTS$1.METADATA_PARSED, this._handleMetadataParsed.bind(this));
        this.on(DEMUX_EVENTS$1.DEMUX_COMPLETE, this._handleDemuxComplete.bind(this));
        this.on(DEMUX_EVENTS$1.DEMUX_ERROR, this._handleDemuxError.bind(this));
        this.on(DEMUX_EVENTS$1.SEI_PARSED, this._handleSEIParsed.bind(this));
        // this.on(BROWSER_EVENTS.VISIBILITY_CHANGE, this._handleVisibilityChange.bind(this))
      }
    }, {
      key: '_handleMediaInfo',
      value: function _handleMediaInfo() {
        if (!this._context.mediaInfo) {
          this.emit(DEMUX_EVENTS$1.DEMUX_ERROR, new Error('failed to get mediainfo'));
        } else {
          if (this._player.video) {
            this._player.video.handleMediaInfo();
          }
        }
      }
    }, {
      key: '_handleLoaderDataLoaded',
      value: function _handleLoaderDataLoaded() {
        this.emitTo('FLV_DEMUXER', DEMUX_EVENTS$1.DEMUX_START);
      }
    }, {
      key: '_handleSEIParsed',
      value: function _handleSEIParsed(sei) {
        this._player.emit('SEI_PARSED', sei);
      }
    }, {
      key: '_handleDemuxComplete',
      value: function _handleDemuxComplete() {
        var _this = this;

        if (this._player.video) {
          var _context$getInstance = this._context.getInstance('TRACKS'),
              videoTrack = _context$getInstance.videoTrack,
              audioTrack = _context$getInstance.audioTrack;

          videoTrack.samples.forEach(function (sample) {
            var buffer = new Stream(sample.data.buffer);
            var nals = void 0;
            if (_this._isHEVC(videoTrack.meta)) {
              nals = NalUnitHEVC.getHvccNals(buffer);
            } else {
              nals = NalUnit.getNalunits(buffer);
            }
            var nalsLength = nals.reduce(function (len, current) {
              return len + 4 + current.body.byteLength;
            }, 0);
            var newData = new Uint8Array(nalsLength);
            var offset = 0;
            nals.forEach(function (nal) {
              newData.set([0, 0, 0, 1], offset);
              offset += 4;
              newData.set(new Uint8Array(nal.body), offset);
              offset += nal.body.byteLength;
            });

            sample.data = newData;
          });
          this._player.video.onDemuxComplete(videoTrack, audioTrack);
        }
      }
    }, {
      key: '_handleVisibilityChange',
      value: function _handleVisibilityChange(hidden) {
        var visible = !hidden;
        if (!visible && !this._player.paused) {
          this._player.pause();
        } else if (visible && this._player.paused) {
          this._player.play();
        }
      }
    }, {
      key: '_handleMetadataParsed',
      value: function _handleMetadataParsed(type) {
        if (type === 'audio') {
          // 将音频meta信息交给audioContext，不走remux封装
          var _context$getInstance2 = this._context.getInstance('TRACKS'),
              audioTrack = _context$getInstance2.audioTrack;

          console.log('audioTrack: ', audioTrack);
          if (audioTrack && audioTrack.meta) {
            this._setMetaToAudio(audioTrack.meta);
          }
        } else {
          var _context$getInstance3 = this._context.getInstance('TRACKS'),
              videoTrack = _context$getInstance3.videoTrack;

          console.log('videoTrack: ', videoTrack);
          if (videoTrack && videoTrack.meta) {
            this._setMetaToVideo(videoTrack.meta);
          }
        }
      }
    }, {
      key: '_setMetaToAudio',
      value: function _setMetaToAudio(audioMeta) {
        if (this._player.video) {
          this._player.video.setAudioMeta(audioMeta);
        }
      }
    }, {
      key: '_setMetaToVideo',
      value: function _setMetaToVideo(videoMeta) {
        if (this._player.video) {
          this._player.video.setVideoMeta(videoMeta);
        }
      }
    }, {
      key: '_handleAppendInitSegment',
      value: function _handleAppendInitSegment() {
        this.state.initSegmentArrived = true;
      }
    }, {
      key: '_handleNetworkError',
      value: function _handleNetworkError(tag, err) {
        this._player.emit('error', new Player.Errors('network', this._player.config.url));
        this._onError(LOADER_EVENTS$1.LOADER_ERROR, tag, err, true, 'MEDIA_ERR_NETWORK');
      }
    }, {
      key: '_handleDemuxError',
      value: function _handleDemuxError(tag, err, fatal) {
        if (fatal === undefined) {
          fatal = false;
        }
        this._player.emit('error', new Player.Errors('parse', this._player.config.url));
        this._onError(DEMUX_EVENTS$1.DEMUX_ERROR, tag, err, fatal, 'MEDIA_ERR_DECODE');
      }
    }, {
      key: '_handleAddRAP',
      value: function _handleAddRAP(rap) {
        if (this.state.randomAccessPoints) {
          this.state.randomAccessPoints.push(rap);
        }
      }
    }, {
      key: '_onError',
      value: function _onError(type, mod, err, fatal, code) {
        var detail = '[' + mod + ']: ' + err.message;
        var error = {
          errorType: type,
          errorDetails: detail,
          errorFatal: fatal || false
        };
        this._player.emit(FLV_ERROR, error);
        if (this._player.video) {
          this._player.video.handleErr(code, detail);
        }
      }
    }, {
      key: '_isHEVC',
      value: function _isHEVC(meta) {
        return meta && meta.codec === 'hev1.1.6.L93.B0';
      }
    }, {
      key: 'seek',
      value: function seek() {
        if (!this.state.initSegmentArrived) {
          this.loadData();
        }
      }
    }, {
      key: 'loadData',
      value: function loadData() {
        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._player.config.url;

        this.emit(LOADER_EVENTS$1.LADER_START, url);
      }
    }, {
      key: 'pause',
      value: function pause() {
        var loader = this._context.getInstance('FETCH_LOADER');

        if (loader) {
          loader.cancel();
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._player = null;
        this.state.randomAccessPoints = [];
      }
    }]);

    return FlvController;
  }();

  var _createClass$e = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$e(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var AudioTrackMeta = function () {
    function AudioTrackMeta(meta) {
      _classCallCheck$e(this, AudioTrackMeta);

      var _default = {
        sampleRate: 48000,
        channelCount: 2,
        codec: 'mp4a.40.2',
        config: [41, 401, 136, 0],
        duration: 0,
        id: 2,
        refSampleDuration: 21,
        sampleRateIndex: 3,
        timescale: 1000,
        type: 'audio'
      };
      if (meta) {
        return Object.assign({}, _default, meta);
      }
      return _default;
    }

    _createClass$e(AudioTrackMeta, [{
      key: 'destroy',
      value: function destroy() {
        this.init = null;
      }
    }]);

    return AudioTrackMeta;
  }();

  var VideoTrackMeta = function () {
    function VideoTrackMeta(meta) {
      _classCallCheck$e(this, VideoTrackMeta);

      var _default = {
        avcc: null,
        sps: new Uint8Array(0),
        pps: new Uint8Array(0),
        chromaFormat: 420,
        codec: 'avc1.640020',
        codecHeight: 720,
        codecWidth: 1280,
        duration: 0,
        frameRate: {
          fixed: true,
          fps: 25,
          fps_num: 25000,
          fps_den: 1000
        },
        id: 1,
        level: '3.2',
        presentHeight: 720,
        presentWidth: 1280,
        profile: 'High',
        refSampleDuration: 40,
        parRatio: {
          height: 1,
          width: 1
        },
        timescale: 1000,
        type: 'video'
      };

      if (meta) {
        return Object.assign({}, _default, meta);
      }
      return _default;
    }

    _createClass$e(VideoTrackMeta, [{
      key: 'destroy',
      value: function destroy() {
        this.init = null;
        this.sps = null;
        this.pps = null;
      }
    }]);

    return VideoTrackMeta;
  }();

  var _createClass$f = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$f(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Golomb$2 = function () {
    function Golomb(uint8array) {
      _classCallCheck$f(this, Golomb);

      this.TAG = 'Golomb';
      this._buffer = uint8array;
      this._bufferIndex = 0;
      this._totalBytes = uint8array.byteLength;
      this._totalBits = uint8array.byteLength * 8;
      this._currentWord = 0;
      this._currentWordBitsLeft = 0;
    }

    _createClass$f(Golomb, [{
      key: 'destroy',
      value: function destroy() {
        this._buffer = null;
      }
    }, {
      key: '_fillCurrentWord',
      value: function _fillCurrentWord() {
        var bufferBytesLeft = this._totalBytes - this._bufferIndex;

        var bytesRead = Math.min(4, bufferBytesLeft);
        var word = new Uint8Array(4);
        word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
        this._currentWord = new DataView(word.buffer).getUint32(0);

        this._bufferIndex += bytesRead;
        this._currentWordBitsLeft = bytesRead * 8;
      }
    }, {
      key: 'readBits',
      value: function readBits(size) {
        var bits = Math.min(this._currentWordBitsLeft, size); // :uint
        var valu = this._currentWord >>> 32 - bits;
        if (size > 32) {
          throw new Error('Cannot read more than 32 bits at a time');
        }
        this._currentWordBitsLeft -= bits;
        if (this._currentWordBitsLeft > 0) {
          this._currentWord <<= bits;
        } else if (this._totalBytes - this._bufferIndex > 0) {
          this._fillCurrentWord();
        }

        bits = size - bits;
        if (bits > 0 && this._currentWordBitsLeft) {
          return valu << bits | this.readBits(bits);
        } else {
          return valu;
        }
      }
    }, {
      key: 'readBool',
      value: function readBool() {
        return this.readBits(1) === 1;
      }
    }, {
      key: 'readByte',
      value: function readByte() {
        return this.readBits(8);
      }
    }, {
      key: '_skipLeadingZero',
      value: function _skipLeadingZero() {
        if (this._currentWordBitsLeft === 0) {
          return 0;
        }
        var zeroCount = void 0;
        for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
          if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {
            this._currentWord <<= zeroCount;
            this._currentWordBitsLeft -= zeroCount;
            return zeroCount;
          }
        }
        this._fillCurrentWord();
        return zeroCount + this._skipLeadingZero();
      }
    }, {
      key: 'readUEG',
      value: function readUEG() {
        // unsigned exponential golomb
        var leadingZeros = this._skipLeadingZero();
        return this.readBits(leadingZeros + 1) - 1;
      }
    }, {
      key: 'readSEG',
      value: function readSEG() {
        // signed exponential golomb
        var value = this.readUEG();
        if (value & 0x01) {
          return value + 1 >>> 1;
        } else {
          return -1 * (value >>> 1);
        }
      }
    }]);

    return Golomb;
  }();

  var _createClass$g = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$g(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var SPSParser$2 = function () {
    function SPSParser() {
      _classCallCheck$g(this, SPSParser);
    }

    _createClass$g(SPSParser, null, [{
      key: '_ebsp2rbsp',
      value: function _ebsp2rbsp(uint8array) {
        var src = uint8array;
        var srcLength = src.byteLength;
        var dst = new Uint8Array(srcLength);
        var dstIdx = 0;

        for (var i = 0; i < srcLength; i++) {
          if (i >= 2) {
            if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
              continue;
            }
          }
          dst[dstIdx] = src[i];
          dstIdx++;
        }

        return new Uint8Array(dst.buffer, 0, dstIdx);
      }
    }, {
      key: 'parseSPS',
      value: function parseSPS(uint8array) {
        var rbsp = SPSParser._ebsp2rbsp(uint8array);
        var gb = new Golomb$2(rbsp);

        var vpsId = 0,
            maxSubLayersMinus1 = 0,
            tINf = 0,
            spsId = 0,
            separate_colour_plane_flag = 0,
            chromaFormatIdc = 0,
            width = 0,
            height = 0,
            conf_win_left_offset = 0,
            conf_win_right_offset = 0,
            conf_win_top_offset = 0,
            conf_win_bottom_offset = 0,
            conformanceWindowFlag = 0,
            bitDepthLumaMinus8 = 0,
            bitDepthChromaMinus8 = 0,
            sub_width_c = 0,
            sub_height_c = 0,
            profileTierLevel = {};

        gb.readByte(); // NAL header
        gb.readByte();

        vpsId = gb.readBits(4); // vps_id
        maxSubLayersMinus1 = gb.readBits(3); // max_sub_layers_minus1
        tINf = gb.readBits(1); // temporal_id_nesting_flag

        profileTierLevel = SPSParser._readProfileTierLevel(gb, maxSubLayersMinus1);

        spsId = gb.readUEG(); // sps id
        chromaFormatIdc = gb.readUEG();
        if (chromaFormatIdc === 3) {
          separate_colour_plane_flag = gb.readBits(1); // separate_colour_plane_flag
        }

        width = gb.readUEG(); // pic_width_in_luma_samples
        height = gb.readUEG(); // pic_height_in_luma_samples

        conformanceWindowFlag = gb.readBits(1);
        if (conformanceWindowFlag === 1) {
          conf_win_left_offset = gb.readUEG(); // conf_win_left_offset
          conf_win_right_offset = gb.readUEG(); // conf_win_right_offset
          conf_win_top_offset = gb.readUEG(); // conf_win_top_offset
          conf_win_bottom_offset = gb.readUEG(); // conf_win_bottom_offset
        }

        bitDepthLumaMinus8 = gb.readUEG(); // bit_depth_luma_minus8
        bitDepthChromaMinus8 = gb.readUEG(); // bit_depth_chroma_minus8

        if (conformanceWindowFlag === 1) {
          sub_width_c = (1 === chromaFormatIdc || 2 === chromaFormatIdc) && 0 === separate_colour_plane_flag ? 2 : 1;
          sub_height_c = 1 === chromaFormatIdc && 0 === separate_colour_plane_flag ? 2 : 1;
          width -= sub_width_c * conf_win_right_offset + sub_width_c * conf_win_left_offset;
          height -= sub_height_c * conf_win_bottom_offset + sub_height_c * conf_win_top_offset;
        }

        gb.destroy();
        gb = null;

        return { width: width, height: height,
          general_profile_space: profileTierLevel.general_profile_space,
          general_tier_flag: profileTierLevel.general_tier_flag,
          general_profile_idc: profileTierLevel.general_profile_idc,
          general_level_idc: profileTierLevel.general_level_idc,
          chromaFormatIdc: chromaFormatIdc,
          bitDepthLumaMinus8: bitDepthLumaMinus8,
          bitDepthChromaMinus8: bitDepthChromaMinus8 };
      }

      // static parseSPS (uint8array) {
      //   let rbsp = SPSParser._ebsp2rbsp(uint8array)
      //   let gb = new Golomb(rbsp)
      //
      //   gb.readByte()
      //   let profileIdc = gb.readByte()
      //   gb.readByte()
      //   let levelIdc = gb.readByte()
      //   gb.readUEG()
      //
      //   let profile_string = SPSParser.getProfileString(profileIdc)
      //   let level_string = SPSParser.getLevelString(levelIdc)
      //   let chroma_format_idc = 1
      //   let chroma_format = 420
      //   let chroma_format_table = [0, 420, 422, 444]
      //   let bit_depth = 8
      //
      //   if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 ||
      //     profileIdc === 244 || profileIdc === 44 || profileIdc === 83 ||
      //     profileIdc === 86 || profileIdc === 118 || profileIdc === 128 ||
      //     profileIdc === 138 || profileIdc === 144) {
      //     chroma_format_idc = gb.readUEG()
      //     if (chroma_format_idc === 3) {
      //       gb.readBits(1)
      //     }
      //     if (chroma_format_idc <= 3) {
      //       chroma_format = chroma_format_table[chroma_format_idc]
      //     }
      //
      //     bit_depth = gb.readUEG() + 8
      //     gb.readUEG()
      //     gb.readBits(1)
      //     if (gb.readBool()) {
      //       let scaling_list_count = (chroma_format_idc !== 3) ? 8 : 12
      //       for (let i = 0; i < scaling_list_count; i++) {
      //         if (gb.readBool()) {
      //           if (i < 6) {
      //             SPSParser._skipScalingList(gb, 16)
      //           } else {
      //             SPSParser._skipScalingList(gb, 64)
      //           }
      //         }
      //       }
      //     }
      //   }
      //   gb.readUEG()
      //   let pic_order_cnt_type = gb.readUEG()
      //   if (pic_order_cnt_type === 0) {
      //     gb.readUEG()
      //   } else if (pic_order_cnt_type === 1) {
      //     gb.readBits(1)
      //     gb.readSEG()
      //     gb.readSEG()
      //     let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG()
      //     for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {
      //       gb.readSEG()
      //     }
      //   }
      //   gb.readUEG()
      //   gb.readBits(1)
      //
      //   let pic_width_in_mbs_minus1 = gb.readUEG()
      //   let pic_height_in_map_units_minus1 = gb.readUEG()
      //
      //   let frame_mbs_only_flag = gb.readBits(1)
      //   if (frame_mbs_only_flag === 0) {
      //     gb.readBits(1)
      //   }
      //   gb.readBits(1)
      //
      //   let frame_crop_left_offset = 0
      //   let frame_crop_right_offset = 0
      //   let frame_crop_top_offset = 0
      //   let frame_crop_bottom_offset = 0
      //
      //   let frame_cropping_flag = gb.readBool()
      //   if (frame_cropping_flag) {
      //     frame_crop_left_offset = gb.readUEG()
      //     frame_crop_right_offset = gb.readUEG()
      //     frame_crop_top_offset = gb.readUEG()
      //     frame_crop_bottom_offset = gb.readUEG()
      //   }
      //
      //   let par_width = 1, par_height = 1
      //   let fps = 0, fps_fixed = true, fps_num = 0, fps_den = 0
      //
      //   let vui_parameters_present_flag = gb.readBool()
      //   if (vui_parameters_present_flag) {
      //     if (gb.readBool()) { // aspect_ratio_info_present_flag
      //       let aspect_ratio_idc = gb.readByte()
      //       let par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2]
      //       let par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1]
      //
      //       if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
      //         par_width = par_w_table[aspect_ratio_idc - 1]
      //         par_height = par_h_table[aspect_ratio_idc - 1]
      //       } else if (aspect_ratio_idc === 255) {
      //         par_width = gb.readByte() << 8 | gb.readByte()
      //         par_height = gb.readByte() << 8 | gb.readByte()
      //       }
      //     }
      //
      //     if (gb.readBool()) {
      //       gb.readBool()
      //     }
      //     if (gb.readBool()) {
      //       gb.readBits(4)
      //       if (gb.readBool()) {
      //         gb.readBits(24)
      //       }
      //     }
      //     if (gb.readBool()) {
      //       gb.readUEG()
      //       gb.readUEG()
      //     }
      //     if (gb.readBool()) {
      //       let num_units_in_tick = gb.readBits(32)
      //       let time_scale = gb.readBits(32)
      //       fps_fixed = gb.readBool()
      //
      //       fps_num = time_scale
      //       fps_den = num_units_in_tick * 2
      //       fps = fps_num / fps_den
      //     }
      //   }
      //
      //   let parScale = 1
      //   if (par_width !== 1 || par_height !== 1) {
      //     parScale = par_width / par_height
      //   }
      //
      //   let crop_unit_x = 0, crop_unit_y = 0
      //   if (chroma_format_idc === 0) {
      //     crop_unit_x = 1
      //     crop_unit_y = 2 - frame_mbs_only_flag
      //   } else {
      //     let sub_wc = (chroma_format_idc === 3) ? 1 : 2
      //     let sub_hc = (chroma_format_idc === 1) ? 2 : 1
      //     crop_unit_x = sub_wc
      //     crop_unit_y = sub_hc * (2 - frame_mbs_only_flag)
      //   }
      //
      //   let codec_width = (pic_width_in_mbs_minus1 + 1) * 16
      //   let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16)
      //
      //   codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x
      //   codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y
      //
      //   let present_width = Math.ceil(codec_width * parScale)
      //
      //   gb.destroy()
      //   gb = null
      //
      //   return {
      //     profile_string: profile_string,
      //     level_string: level_string,
      //     bit_depth: bit_depth,
      //     chroma_format: chroma_format,
      //     chroma_format_string: SPSParser.getChromaFormatString(chroma_format),
      //
      //     frame_rate: {
      //       fixed: fps_fixed,
      //       fps: fps,
      //       fps_den: fps_den,
      //       fps_num: fps_num
      //     },
      //
      //     par_ratio: {
      //       width: par_width,
      //       height: par_height
      //     },
      //
      //     codec_size: {
      //       width: codec_width,
      //       height: codec_height
      //     },
      //
      //     present_size: {
      //       width: present_width,
      //       height: codec_height
      //     }
      //   }
      // }

    }, {
      key: '_readProfileTierLevel',
      value: function _readProfileTierLevel(gb, maxSubLayersMinus1) {
        var general_profile_space = 0;
        var general_tier_flag = 0;
        var general_profile_idc = 0;
        var general_level_idc = 0;
        general_profile_space = gb.readBits(2) || 0; // profile_space
        general_tier_flag = gb.readBits(1) || 0; // tierFlag
        general_profile_idc = gb.readBits(5) || 0; // profileIdc

        gb.readBits(16); // some 32bits
        gb.readBits(16);

        gb.readBits(1); // progressiveSourceFlag
        gb.readBits(1); // interlacedSourceFlag
        gb.readBits(1); // nonPackedConstraintFlag
        gb.readBits(1); // frameOnlyConstraintFlag


        gb.readBits(16); // reserved zero bits
        gb.readBits(16);
        gb.readBits(12);

        general_level_idc = gb.readBits(8) || 0; // level_idc

        var subLayerProfilePresentFlag = [];
        var subLayerLevelPresentFlag = [];
        for (var j = 0; j < maxSubLayersMinus1; j++) {
          subLayerProfilePresentFlag[j] = gb.readBits(1);
          subLayerLevelPresentFlag[j] = gb.readBits(1);
        }

        if (maxSubLayersMinus1 > 0) {
          gb.readBits((8 - maxSubLayersMinus1) * 2);
        }

        for (var i = 0; i < maxSubLayersMinus1; i++) {
          if (subLayerProfilePresentFlag[i] !== 0) {
            gb.readBits(2);
            gb.readBits(1);
            gb.readBits(5);

            gb.readBits(16);
            gb.readBits(16);

            gb.readBits(4);

            gb.readBits(16);
            gb.readBits(16);
            gb.readBits(12);
          }
          if (subLayerLevelPresentFlag[i] !== 0) {
            gb.readBits(8);
          }
        }

        return {
          general_profile_space: general_profile_space,
          general_tier_flag: general_tier_flag,
          general_profile_idc: general_profile_idc,
          general_level_idc: general_level_idc
        };
      }
    }, {
      key: '_skipScalingList',
      value: function _skipScalingList(gb, count) {
        var lastScale = 8;
        var nextScale = 8;
        var deltaScale = 0;
        for (var i = 0; i < count; i++) {
          if (nextScale !== 0) {
            deltaScale = gb.readSEG();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      }
    }, {
      key: 'getProfileString',
      value: function getProfileString(profileIdc) {
        switch (profileIdc) {
          case 66:
            return 'Baseline';
          case 77:
            return 'Main';
          case 88:
            return 'Extended';
          case 100:
            return 'High';
          case 110:
            return 'High10';
          case 122:
            return 'High422';
          case 244:
            return 'High444';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'getLevelString',
      value: function getLevelString(levelIdc) {
        return (levelIdc / 10).toFixed(1);
      }
    }, {
      key: 'getChromaFormatString',
      value: function getChromaFormatString(chroma) {
        switch (chroma) {
          case 420:
            return '4:2:0';
          case 422:
            return '4:2:2';
          case 444:
            return '4:4:4';
          default:
            return 'Unknown';
        }
      }
    }, {
      key: 'toVideoMeta',
      value: function toVideoMeta(spsConfig) {
        var meta = {};
        if (spsConfig) {
          meta.codecWidth = spsConfig.width;
          meta.codecHeight = spsConfig.height;
          meta.presentWidth = spsConfig.width;
          meta.presentHeight = spsConfig.height;
        }

        meta.profile = spsConfig.profile_string;
        meta.level = spsConfig.level_string;
        meta.bitDepth = spsConfig.bit_depth;
        meta.chromaFormat = spsConfig.chroma_format;

        // meta.parRatio = {
        //   width: spsConfig.par_ratio.width,
        //   height: spsConfig.par_ratio.height
        // }

        // meta.frameRate = spsConfig.frame_rate

        // let fpsDen = meta.frameRate.fps_den
        // let fpsNum = meta.frameRate.fps_num
        // meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum))
        return meta;
      }
    }]);

    return SPSParser;
  }();

  var _createClass$h = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$h(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var RBSP$2 = function () {
    function RBSP() {
      _classCallCheck$h(this, RBSP);
    }

    _createClass$h(RBSP, null, [{
      key: "EBSP2RBSP",

      /**
       * convert EBSP to RBSP
       * @param data {Uint8Array}
       * @returns {Uint8Array}
       * @constructor
       */
      value: function EBSP2RBSP(data) {
        return data.filter(function (el, idx) {
          if (idx < 2) {
            return true;
          } else {
            return !(data[idx - 2] === 0 && data[idx - 1] === 0 && el === 3);
          }
        });
      }

      /**
       * @param data {Uint8Array}
       * @constructor
       */

    }, {
      key: "EBSP2SODB",
      value: function EBSP2SODB(data) {
        var lastByte = data[data.byteLength - 1];
        if (lastByte && lastByte === 128) {
          return data.slice(0, data.byteLength - 1);
        }

        return data;
      }
    }]);

    return RBSP;
  }();

  var _createClass$i = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$i(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var u8aToString$2 = function u8aToString(data) {
    var result = '';
    for (var i = 0; i < data.byteLength; i++) {
      result += String.fromCharCode(data[i]);
    }
    return result;
  };

  var SEIParser$2 = function () {
    function SEIParser() {
      _classCallCheck$i(this, SEIParser);
    }

    _createClass$i(SEIParser, null, [{
      key: '_resolveNalu',
      value: function _resolveNalu(data) {
        if (data.length >= 1) {
          return RBSP$2.EBSP2SODB(RBSP$2.EBSP2RBSP(data.slice(1)));
        }
        return null;
      }
      /**
       *
       * @param data {Uint8Array}
       */

    }, {
      key: 'parse',
      value: function parse(data) {
        var sodb = SEIParser._resolveNalu(data);

        var _SEIParser$switchPayl = SEIParser.switchPayloadType(sodb),
            payloadType = _SEIParser$switchPayl.payloadType,
            offset = _SEIParser$switchPayl.offset;

        var content = sodb.slice(offset);

        switch (payloadType) {
          case 5:
            return SEIParser.user_data_unregistered(content);
          default:
            return {
              code: payloadType,
              content: content
            };
        }
      }

      /**
       *
       * @param data
       * @returns {{payloadType: number, offset: number}}
       */

    }, {
      key: 'switchPayloadType',
      value: function switchPayloadType(data) {
        var dv = new DataView(data.buffer);
        var payloadType = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadType += 255;
        }
        payloadType += dv.getUint8(offset++);

        return {
          payloadType: payloadType,
          offset: offset
        };
      }

      /**
       *
       * @param data {Uint8Array}
       * @return {{ payloadLength: number, offset: number }}
       */

    }, {
      key: 'getPayloadLength',
      value: function getPayloadLength(data) {
        var dv = new DataView(data.buffer);

        var payloadLength = 0;
        var offset = 0;
        while (dv.getUint8(offset) === 255) {
          offset++;
          payloadLength += 255;
        }
        payloadLength += dv.getUint8(offset++);

        return {
          payloadLength: payloadLength,
          offset: offset
        };
      }

      /**
       * resolve 0x05 user data unregistered
       * @param data {Uint8Array}
       */
      // eslint-disable-next-line camelcase

    }, {
      key: 'user_data_unregistered',
      value: function user_data_unregistered(data) {
        var _SEIParser$getPayload = SEIParser.getPayloadLength(data),
            payloadLength = _SEIParser$getPayload.payloadLength,
            offset = _SEIParser$getPayload.offset;

        if (payloadLength < 16) {
          return {
            uuid: '',
            content: null
          };
        }
        var payload = data.slice(offset);

        var uuid = u8aToString$2(payload.slice(0, 16));
        var content = u8aToString$2(payload.slice(16, payloadLength));

        return {
          code: 5, // for user data unregistered
          uuid: uuid,
          content: content
        };
      }
    }]);

    return SEIParser;
  }();

  var _createClass$j = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$j(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Nalunit$2 = function () {
    function Nalunit() {
      _classCallCheck$j(this, Nalunit);
    }

    _createClass$j(Nalunit, null, [{
      key: 'getNalunits',
      value: function getNalunits(buffer) {
        if (buffer.length - buffer.position < 4) {
          return [];
        }

        var buf = buffer.dataview;
        var position = buffer.position;
        // console.log('getNalunits')
        // console.log('buf: ', buf)
        // console.log(buf.getInt8(position))
        // console.log(buf.getInt8(position+1))
        // console.log(buf.getInt8(position+2))
        // console.log(buf.getInt8(position+3))
        if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {
          return Nalunit.getAnnexbNals(buffer);
        } else {
          return Nalunit.getHvccNals(buffer);
        }
      }
    }, {
      key: 'getAnnexbNals',
      value: function getAnnexbNals(buffer) {
        // console.log('getAnnexbNals')
        // console.log('buffer: ', buffer)
        var nals = [];
        var position = Nalunit.getHeaderPositionAnnexB(buffer);
        var start = position.pos;
        var end = start;
        while (start < buffer.length - 4) {
          var header = buffer.buffer.slice(start, start + position.headerLength);
          if (position.pos === buffer.position) {
            buffer.skip(position.headerLength);
          }
          position = Nalunit.getHeaderPositionAnnexB(buffer);
          end = position.pos;
          var body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));
          var unit = { header: header, body: body };
          Nalunit.analyseNal(unit);
          if (unit.type <= 40) {
            nals.push(unit);
          }
          buffer.skip(end - buffer.position);
          start = end;
        }
        return nals;
      }
    }, {
      key: 'getHvccNals',
      value: function getHvccNals(buffer) {
        // console.log('getHvccNals')
        var nals = [];
        while (buffer.position < buffer.length - 4) {
          // console.log('buffer')
          // console.log(buffer)
          // console.log(buffer.position)
          // console.log(buffer.length)
          // console.log(buffer.dataview)
          // let length = buffer.dataview.getInt32();
          var length = buffer.dataview.getInt32(buffer.dataview.position);
          if (buffer.length - buffer.position >= length) {
            var header = buffer.buffer.slice(buffer.position, buffer.position + 4);
            buffer.skip(4);
            var body = new Uint8Array(buffer.buffer.slice(buffer.position, buffer.position + length));
            buffer.skip(length);
            var unit = { header: header, body: body };
            try {
              Nalunit.analyseNal(unit);
            } catch (error) {
              continue;
            }
            if (unit.type <= 40) {
              nals.push(unit);
            }
          } else {
            break;
          }
        }
        return nals;
      }
    }, {
      key: 'analyseNal',
      value: function analyseNal(unit) {
        // console.log('analyseNal')
        // console.log('unit: ', unit)
        // console.log(unit.body[0] >>> 1)
        var type = unit.body[0] >>> 1 & 0x3f;
        // console.log('type: ', type)
        unit.type = type;
        switch (type) {
          case 0:
            // SLICE_TRAIL_N
            unit.slice_trail_n = true;
            break;
          case 1:
            // SLICE_TRAIL_R
            unit.slice_trail_r = true;
            unit.key = true;
            break;
          case 2:
            // SLICE_TSA_N
            unit.slice_tsa_n = true;
            break;
          case 3:
            // SLICE_TSA_R
            unit.slice_tsa_r = true;
            unit.key = true;
            break;
          case 4:
            // SLICE_STSA_N
            unit.slice_stsa_n = true;
            break;
          case 5:
            // SLICE_STSA_R
            unit.slice_stsa_r = true;
            unit.key = true;
            break;
          case 6:
            // SLICE_RADL_N
            unit.slice_radl_n = true;
            break;
          case 7:
            // SLICE_RADL_R
            unit.slice_radl_r = true;
            unit.key = true;
            break;
          case 8:
            // SLICE_RASL_N
            unit.slice_rasl_n = true;
            break;
          case 9:
            // SLICE_RASL_R
            unit.slice_rasl_r = true;
            unit.key = true;
            break;
          case 16:
            // SLICE_BLA_W_LP
            unit.slice_bla_w_lp = true;
            break;
          case 17:
            // SLICE_BLA_W_RADL
            unit.slice_bla_w_radl = true;
            break;
          case 18:
            // SLICE_BLA_N_LP
            unit.slice_bla_n_lp = true;
            break;
          case 19:
            // SLICE_IDR_W_RADL
            unit.slice_idl_w_radl = true;
            unit.key = true;
            break;
          case 20:
            // SLICE_IDR_N_LP
            unit.slice_idr_n_lp = true;
            unit.key = true;
            break;
          case 21:
            // SLICE_CRA_NUT
            unit.slice_cra_nut = true;
            unit.key = true;
            break;
          case 32:
            // VPS
            unit.vps = true;
            break;
          case 33:
            // SPS
            unit.sps = SPSParser$2.parseSPS(unit.body);
            break;
          case 34:
            // PPS
            unit.pps = true;
            break;
          case 35:
            // AUD
            break;
          case 36:
            // EOS
            unit.aud = true;
            break;
          case 37:
            // EOB
            unit.eob = true;
            break;
          case 38:
            // FD
            unit.fd = true;
            break;
          case 39:
            // PREFIX_SEI
            // unit.prefix_sei = true;
            unit.sei = SEIParser$2.parse(unit.body.slice(1));
            break;
          case 40:
            // SUFFIX_SEI
            unit.sei = SEIParser$2.parse(unit.body.slice(1));
            break;
          // case 1:
          //   // NDR
          //   unit.ndr = true;
          //   break;
          // case 5:
          //   // IDR
          //   unit.idr = true;
          //   break;
          // case 6:
          //   // SEI
          //   break;
          // case 7:
          //   // SPS
          //   unit.sps = SpsParser.parseSPS(unit.body);
          //   break;
          // case 8:
          //   // PPS
          //   unit.pps = true;
          //   break;
          // case 9:
          //   // AUD
          //   break;
          // default:
          //   break;
        }
      }
    }, {
      key: 'getHeaderPositionAnnexB',
      value: function getHeaderPositionAnnexB(buffer) {
        // seperate
        var pos = buffer.position;
        var headerLength = 0;
        var bufferLen = buffer.length;
        while (headerLength !== 3 && headerLength !== 4 && pos < bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            } else if (buffer.dataview.getInt8(pos + 2) === 1) {
              headerLength = 3;
            } else {
              pos++;
            }
          } else {
            pos++;
          }
        }

        if (pos === bufferLen - 4) {
          if (buffer.dataview.getInt16(pos) === 0) {
            if (buffer.dataview.getInt16(pos + 2) === 1) {
              // 0x000001
              headerLength = 4;
            }
          } else {
            pos++;
            if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {
              // 0x0000001
              headerLength = 3;
            } else {
              pos = bufferLen;
            }
          }
        }
        return { pos: pos, headerLength: headerLength };
      }

      // static getAvcc (sps, pps) {
      //   let ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);
      //   ret[0] = 0x01;
      //   ret[1] = sps[1];
      //   ret[2] = sps[2];
      //   ret[3] = sps[3];
      //   ret[4] = 255;
      //   ret[5] = 225;
      //
      //   let offset = 6;
      //
      //   ret.set(new Uint8Array([(sps.byteLength >>> 8) & 0xff, sps.byteLength & 0xff]), offset);
      //   offset += 2;
      //   ret.set(sps, offset);
      //   offset += sps.byteLength;
      //
      //   ret[offset] = 1;
      //   offset++;
      //
      //   ret.set(new Uint8Array([(pps.byteLength >>> 8) & 0xff, pps.byteLength & 0xff]), offset);
      //   offset += 2;
      //   ret.set(pps, offset);
      //   return ret;
      // }

    }]);

    return Nalunit;
  }();

  var SpsParserHEVC = SPSParser$2;
  var NalUnitHEVC$1 = Nalunit$2;

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass$k = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _possibleConstructorReturn$1(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof$1(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof$1(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck$k(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Track = function () {
    /**
     * The constructor.
     */
    function Track() {
      _classCallCheck$k(this, Track);

      this.id = -1;
      this.sequenceNumber = 0;
      this.samples = [];
      this.droppedSamples = [];
      this.length = 0;
    }

    /**
     * Reset the track.
     */

    _createClass$k(Track, [{
      key: 'reset',
      value: function reset() {
        this.sequenceNumber = 0;
        this.samples = [];
        this.length = 0;
      }
      /**
       * destroy the track.
       */

    }, {
      key: 'distroy',
      value: function distroy() {
        this.reset();
        this.id = -1;
      }
    }]);

    return Track;
  }();

  var AudioTrack = function (_Track) {
    _inherits$1(AudioTrack, _Track);

    /**
     * The constructor for audio track.
     */
    function AudioTrack() {
      _classCallCheck$k(this, AudioTrack);

      var _this = _possibleConstructorReturn$1(this, (AudioTrack.__proto__ || Object.getPrototypeOf(AudioTrack)).call(this));

      _this.TAG = 'AudioTrack';
      _this.type = 'audio';
      return _this;
    }

    return AudioTrack;
  }(Track);

  var VideoTrack = function (_Track2) {
    _inherits$1(VideoTrack, _Track2);

    /**
     * The constructor for video track.
     */
    function VideoTrack() {
      _classCallCheck$k(this, VideoTrack);

      var _this2 = _possibleConstructorReturn$1(this, (VideoTrack.__proto__ || Object.getPrototypeOf(VideoTrack)).call(this));

      _this2.TAG = 'VideoTrack';
      _this2.type = 'video';
      _this2.dropped = 0;
      return _this2;
    }
    /**
     * reset the video track.
     */

    _createClass$k(VideoTrack, [{
      key: 'reset',
      value: function reset() {
        this.sequenceNumber = 0;
        this.samples = [];
        this.length = 0;
        this.dropped = 0;
      }
    }]);

    return VideoTrack;
  }(Track);

  var Tracks = function () {
    function Tracks() {
      _classCallCheck$k(this, Tracks);

      this.audioTrack = null;
      this.videoTrack = null;
    }

    _createClass$k(Tracks, [{
      key: 'destroy',
      value: function destroy() {
        this.audioTrack = null;
        this.videoTrack = null;
      }
    }]);

    return Tracks;
  }();

  var _createClass$l = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$l(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var BROWSER_EVENTS$1 = EVENTS.BROWSER_EVENTS;
  var hidden = void 0;
  var visibilityChange = void 0;

  if (typeof document.hidden !== 'undefined') {
    // Opera 12.10 and Firefox 18 and later support
    hidden = 'hidden';
    visibilityChange = 'visibilitychange';
  } else if (typeof document.msHidden !== 'undefined') {
    hidden = 'msHidden';
    visibilityChange = 'msvisibilitychange';
  } else if (typeof document.webkitHidden !== 'undefined') {
    hidden = 'webkitHidden';
    visibilityChange = 'webkitvisibilitychange';
  }

  var PageVisibility = function () {
    function PageVisibility() {
      _classCallCheck$l(this, PageVisibility);

      this.callbacks = {
        onShow: [],
        onHidden: []
      };
      this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      this.init();
    }

    _createClass$l(PageVisibility, [{
      key: 'init',
      value: function init() {
        document.addEventListener(visibilityChange, this.handleVisibilityChange, false);
      }
    }, {
      key: 'handleVisibilityChange',
      value: function handleVisibilityChange() {
        this.emit(BROWSER_EVENTS$1.VISIBILITY_CHANGE, document[hidden]);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        document.removeEventListener(visibilityChange, this.handleVisibilityChange);
      }
    }]);

    return PageVisibility;
  }();

  var le = function () {
    var buf = new ArrayBuffer(2);
    new DataView(buf).setInt16(0, 256, true); // little-endian write
    return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE
  }();

  var sniffer = {
    get device() {
      var r = sniffer.os;
      return r.isPc ? 'pc' : r.isTablet ? 'tablet' : 'mobile';
    },
    get browser() {
      var ua = navigator.userAgent.toLowerCase();
      var reg = {
        ie: /rv:([\d.]+)\) like gecko/,
        firfox: /firefox\/([\d.]+)/,
        chrome: /chrome\/([\d.]+)/,
        opera: /opera.([\d.]+)/,
        safari: /version\/([\d.]+).*safari/
      };
      return [].concat(Object.keys(reg).filter(function (key) {
        return reg[key].test(ua);
      }))[0];
    },
    get os() {
      var ua = navigator.userAgent;
      var isWindowsPhone = /(?:Windows Phone)/.test(ua);
      var isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone;
      var isAndroid = /(?:Android)/.test(ua);
      var isFireFox = /(?:Firefox)/.test(ua);
      var isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua);
      var isPhone = /(?:iPhone)/.test(ua) && !isTablet;
      var isPc = !isPhone && !isAndroid && !isSymbian;
      return {
        isTablet: isTablet,
        isPhone: isPhone,
        isAndroid: isAndroid,
        isPc: isPc,
        isSymbian: isSymbian,
        isWindowsPhone: isWindowsPhone,
        isFireFox: isFireFox
      };
    },

    get isLe() {
      return le;
    }
  };

  var _createClass$m = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$m(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var UTF8 = function () {
    function UTF8() {
      _classCallCheck$m(this, UTF8);
    }

    _createClass$m(UTF8, null, [{
      key: 'decode',
      value: function decode(uint8array) {
        var out = [];
        var input = uint8array;
        var i = 0;
        var length = uint8array.length;

        while (i < length) {
          if (input[i] < 0x80) {
            out.push(String.fromCharCode(input[i]));
            ++i;
            continue;
          } else if (input[i] < 0xC0) ; else if (input[i] < 0xE0) {
            if (UTF8._checkContinuation(input, i, 1)) {
              var ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;
              if (ucs4 >= 0x80) {
                out.push(String.fromCharCode(ucs4 & 0xFFFF));
                i += 2;
                continue;
              }
            }
          } else if (input[i] < 0xF0) {
            if (UTF8._checkContinuation(input, i, 2)) {
              var _ucs = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;
              if (_ucs >= 0x800 && (_ucs & 0xF800) !== 0xD800) {
                out.push(String.fromCharCode(_ucs & 0xFFFF));
                i += 3;
                continue;
              }
            }
          } else if (input[i] < 0xF8) {
            if (UTF8._checkContinuation(input, i, 3)) {
              var _ucs2 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;
              if (_ucs2 > 0x10000 && _ucs2 < 0x110000) {
                _ucs2 -= 0x10000;
                out.push(String.fromCharCode(_ucs2 >>> 10 | 0xD800));
                out.push(String.fromCharCode(_ucs2 & 0x3FF | 0xDC00));
                i += 4;
                continue;
              }
            }
          }
          out.push(String.fromCharCode(0xFFFD));
          ++i;
        }

        return out.join('');
      }
    }, {
      key: '_checkContinuation',
      value: function _checkContinuation(uint8array, start, checkLength) {
        var array = uint8array;
        if (start + checkLength < array.length) {
          while (checkLength--) {
            if ((array[++start] & 0xC0) !== 0x80) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
    }]);

    return UTF8;
  }();

  var _createClass$n = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$n(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var isLe = sniffer.isLe;

  var DATA_TYPES = {
    NUMBER: 0,
    BOOLEAN: 1,
    STRING: 2,
    OBJECT: 3,
    MIX_ARRAY: 8,
    OBJECT_END: 9,
    STRICT_ARRAY: 10,
    DATE: 11,
    LONE_STRING: 12

    /**
     * meta信息解析
     */
  };
  var AMFParser = function () {
    function AMFParser() {
      _classCallCheck$n(this, AMFParser);

      this.offset = 0;
      this.readOffset = this.offset;
    }

    _createClass$n(AMFParser, [{
      key: 'resolve',
      value: function resolve(meta, size) {
        if (size < 3) {
          throw new Error('not enough data for metainfo');
        }
        var metaData = {};
        var name = this.parseValue(meta);
        var value = this.parseValue(meta, size - name.bodySize);
        metaData[name.data] = value.data;

        this.resetStatus();
        return metaData;
      }
    }, {
      key: 'resetStatus',
      value: function resetStatus() {
        this.offset = 0;
        this.readOffset = this.offset;
      }
    }, {
      key: 'parseString',
      value: function parseString(buffer) {
        var dv = new DataView(buffer, this.readOffset);
        var strLen = dv.getUint16(0, !isLe);
        var str = '';
        if (strLen > 0) {
          str = UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));
        } else {
          str = '';
        }
        var size = strLen + 2;
        this.readOffset += size;
        return {
          data: str,
          bodySize: strLen + 2
        };
      }
    }, {
      key: 'parseDate',
      value: function parseDate(buffer, size) {
        var dv = new DataView(buffer, this.readOffset, size);
        var ts = dv.getFloat64(0, !isLe);
        var timeOffset = dv.getInt16(8, !isLe);
        ts += timeOffset * 60 * 1000;

        this.readOffset += 10;
        return {
          data: new Date(ts),
          bodySize: 10
        };
      }
    }, {
      key: 'parseObject',
      value: function parseObject(buffer, size) {
        var name = this.parseString(buffer, size);
        var value = this.parseValue(buffer, size - name.bodySize);
        return {
          data: {
            name: name.data,
            value: value.data
          },
          bodySize: name.bodySize + value.bodySize,
          isObjEnd: value.isObjEnd
        };
      }
    }, {
      key: 'parseLongString',
      value: function parseLongString(buffer) {
        var dv = new DataView(buffer, this.readOffset);
        var strLen = dv.getUint32(0, !isLe);
        var str = '';
        if (strLen > 0) {
          str = UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));
        } else {
          str = '';
        }
        // const size = strLen + 4;
        this.readOffset += strLen + 4;
        return {
          data: str,
          bodySize: strLen + 4
        };
      }

      /**
       * 解析meta中的变量
       */

    }, {
      key: 'parseValue',
      value: function parseValue(data, size) {
        var buffer = new ArrayBuffer();
        if (data instanceof ArrayBuffer) {
          buffer = data;
        } else {
          buffer = data.buffer;
        }
        var NUMBER = DATA_TYPES.NUMBER,
            BOOLEAN = DATA_TYPES.BOOLEAN,
            STRING = DATA_TYPES.STRING,
            OBJECT = DATA_TYPES.OBJECT,
            MIX_ARRAY = DATA_TYPES.MIX_ARRAY,
            OBJECT_END = DATA_TYPES.OBJECT_END,
            STRICT_ARRAY = DATA_TYPES.STRICT_ARRAY,
            DATE = DATA_TYPES.DATE,
            LONE_STRING = DATA_TYPES.LONE_STRING;

        var dataView = new DataView(buffer, this.readOffset, size);
        var isObjEnd = false;
        var type = dataView.getUint8(0);
        var offset = 1;
        this.readOffset += 1;
        var value = null;

        switch (type) {
          case NUMBER:
            {
              value = dataView.getFloat64(1, !isLe);
              this.readOffset += 8;
              offset += 8;
              break;
            }
          case BOOLEAN:
            {
              var boolNum = dataView.getUint8(1);
              value = !!boolNum;
              this.readOffset += 1;
              offset += 1;
              break;
            }
          case STRING:
            {
              var str = this.parseString(buffer);
              value = str.data;
              offset += str.bodySize;
              break;
            }
          case OBJECT:
            {
              value = {};
              var objEndSize = 0;
              if (dataView.getUint32(size - 4, !isLe) & 0x00FFFFFF) {
                objEndSize = 3;
              }
              // this.readOffset += offset - 1;
              while (offset < size - 4) {
                var amfObj = this.parseObject(buffer, size - offset - objEndSize);
                if (amfObj.isObjectEnd) {
                  break;
                }
                value[amfObj.data.name] = amfObj.data.value;
                offset += amfObj.bodySize;
              }
              if (offset <= size - 3) {
                var mark = dataView.getUint32(offset - 1, !isLe) & 0x00FFFFFF;
                if (mark === 9) {
                  this.readOffset += 3;
                  offset += 3;
                }
              }
              break;
            }
          case MIX_ARRAY:
            {
              value = {};
              offset += 4;
              this.readOffset += 4;
              var _objEndSize = 0;
              if ((dataView.getUint32(size - 4, !isLe) & 0x00FFFFFF) === 9) {
                _objEndSize = 3;
              }

              while (offset < size - 8) {
                var amfVar = this.parseObject(buffer, size - offset - _objEndSize);
                if (amfVar.isObjectEnd) {
                  break;
                }
                value[amfVar.data.name] = amfVar.data.value;
                offset += amfVar.bodySize;
              }
              if (offset <= size - 3) {
                var marker = dataView.getUint32(offset - 1, !isLe) & 0x00FFFFFF;
                if (marker === 9) {
                  offset += 3;
                  this.readOffset += 3;
                }
              }
              break;
            }

          case OBJECT_END:
            {
              value = null;
              isObjEnd = true;
              break;
            }

          case STRICT_ARRAY:
            {
              value = [];
              var arrLength = dataView.getUint32(1, !isLe);
              offset += 4;
              this.readOffset += 4;
              for (var i = 0; i < arrLength; i++) {
                var script = this.parseValue(buffer, size - offset);
                value.push(script.data);
                offset += script.bodySize;
              }
              break;
            }

          case DATE:
            {
              var date = this.parseDate(buffer, size - 1);
              value = date.data;
              offset += date.bodySize;
              break;
            }

          case LONE_STRING:
            {
              var longStr = this.parseLongString(buffer, size - 1);
              value = longStr.data;
              offset += longStr.bodySize;
              break;
            }

          default:
            {
              offset = size;
            }
        }

        return {
          data: value,
          bodySize: offset,
          isObjEnd: isObjEnd
        };
      }
    }]);

    return AMFParser;
  }();

  var _createClass$o = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$o(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var DEMUX_EVENTS$2 = EVENTS.DEMUX_EVENTS;

  var FlvDemuxer = function () {
    function FlvDemuxer() {
      _classCallCheck$o(this, FlvDemuxer);

      this._firstFragmentLoaded = false;
      this._trackNum = 0;
      this._hasScript = false;
      this._videoMetaChange = false;
      this._audioMetaChange = false;
    }

    _createClass$o(FlvDemuxer, [{
      key: 'init',
      value: function init() {
        this.on(DEMUX_EVENTS$2.DEMUX_START, this.doParseFlv.bind(this));
      }

      /**
       * if the flv head is valid
       * @param data
       * @returns {boolean}
       */

    }, {
      key: 'doParseFlv',
      value: function doParseFlv() {
        if (!this._firstFragmentLoaded) {
          if (this.loaderBuffer.length < 13) {
            return;
          }
          var header = this.loaderBuffer.shift(13);
          this.parseFlvHeader(header);
          this.doParseFlv(); // 递归调用，继续解析flv流
        } else {
          if (this.loaderBuffer.length < 11) {
            return;
          }
          var chunk = void 0;

          var loopMax = 10000; // 防止死循环产生
          do {
            // console.log('mark4')
            chunk = this._parseFlvTag();
          } while (chunk && loopMax-- > 0);

          this.emit(DEMUX_EVENTS$2.DEMUX_COMPLETE);
        }
      }
    }, {
      key: 'parseFlvHeader',
      value: function parseFlvHeader(header) {
        if (!FlvDemuxer.isFlvFile(header)) {
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, new Error('invalid flv file'));
          this.doParseFlv();
        } else {
          this._firstFragmentLoaded = true;
          // const playType = FlvDemuxer.getPlayType(header[4])

          this.initVideoTrack();
          this.initAudioTrack();
        }
        this.doParseFlv();
      }

      /**
       * init default video track configs
       */

    }, {
      key: 'initVideoTrack',
      value: function initVideoTrack() {
        this._trackNum++;
        var videoTrack = new VideoTrack();
        videoTrack.meta = new VideoTrackMeta();
        videoTrack.id = videoTrack.meta.id = this._trackNum;

        this.tracks.videoTrack = videoTrack;
      }

      /**
       * init default audio track configs
       */

    }, {
      key: 'initAudioTrack',
      value: function initAudioTrack() {
        this._trackNum++;
        var audioTrack = new AudioTrack();
        audioTrack.meta = new AudioTrackMeta();
        audioTrack.id = audioTrack.meta.id = this._trackNum;

        this.tracks.audioTrack = audioTrack;
      }

      /**
       * Package the data as the following data structure
       * {
       *    data: Uint8Array. the Stream data.
       *    info: The first byte info of the Tag.
       *    tagType: 8、9、18
       *    timeStamp: the timestemp
       * }
       */

    }, {
      key: '_parseFlvTag',
      value: function _parseFlvTag() {
        if (this.loaderBuffer.length < 11) {
          return null;
        }
        var chunk = this._parseFlvTagHeader();
        if (chunk) {
          this._processChunk(chunk);
        }
        return chunk;
      }

      /**
       * Parse the 11 byte tag Header
       */

    }, {
      key: '_parseFlvTagHeader',
      value: function _parseFlvTagHeader() {
        var offset = 0;
        var chunk = {};

        var tagType = this.loaderBuffer.toInt(offset, 1);
        offset += 1;

        // 2 bit FMS reserved, 1 bit filtered, 5 bit tag type
        chunk.filtered = (tagType & 32) >>> 5;
        chunk.tagType = tagType & 31;

        // 3 Byte datasize
        chunk.datasize = this.loaderBuffer.toInt(offset, 3);
        offset += 3;

        if (chunk.tagType !== 8 && chunk.tagType !== 9 && chunk.tagType !== 11 && chunk.tagType !== 18 || this.loaderBuffer.toInt(8, 3) !== 0) {
          if (this.loaderBuffer && this.loaderBuffer.length > 0) {
            this.loaderBuffer.shift(1);
          }
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, this.TAG, new Error('tagType ' + chunk.tagType), false);
          return null;
        }

        if (this.loaderBuffer.length < chunk.datasize + 15) {
          return null;
        }

        // read the data.
        this.loaderBuffer.shift(4);

        // 3 Byte timestamp
        var timestamp = this.loaderBuffer.toInt(0, 3);
        this.loaderBuffer.shift(3);

        // 1 Byte timestampExt
        var timestampExt = this.loaderBuffer.shift(1)[0];
        if (timestampExt > 0) {
          timestamp += timestampExt * 0x1000000;
        }

        chunk.dts = timestamp;

        // streamId
        this.loaderBuffer.shift(3);
        return chunk;
      }
    }, {
      key: '_processChunk',
      value: function _processChunk(chunk) {
        switch (chunk.tagType) {
          case 18:
            this._parseScriptData(chunk);
            break;
          case 8:
            this._parseAACData(chunk);
            break;
          case 9:
            this._parseHevcData(chunk);
            break;
          case 11:
            // for some CDN that did not process the currect RTMP messages
            this.loaderBuffer.shift(3);
            break;
          default:
            this.loaderBuffer.shift(1);
        }
      }

      /**
       * parse flv script data
       * @param chunk
       * @private
       */

    }, {
      key: '_parseScriptData',
      value: function _parseScriptData(chunk) {
        var audioTrack = this.tracks.audioTrack;
        var videoTrack = this.tracks.videoTrack;

        var data = this.loaderBuffer.shift(chunk.datasize);

        var info = new AMFParser().resolve(data, data.length);

        var onMetaData = this._context.onMetaData = info ? info.onMetaData : undefined;

        // fill mediaInfo
        this._context.mediaInfo.duration = onMetaData.duration;
        this._context.mediaInfo.hasVideo = onMetaData.hasVideo;
        this._context.mediaInfo.hsaAudio = onMetaData.hasAudio;

        var validate = this._datasizeValidator(chunk.datasize);
        if (validate) {
          this.emit(DEMUX_EVENTS$2.MEDIA_INFO);
          this._hasScript = true;
        }

        // Edit default meta.
        if (audioTrack && !audioTrack.hasSpecificConfig) {
          var meta = audioTrack.meta;
          if (onMetaData.audiosamplerate) {
            meta.sampleRate = onMetaData.audiosamplerate;
          }

          if (onMetaData.audiochannels) {
            meta.channelCount = onMetaData.audiochannels;
          }

          switch (onMetaData.audiosamplerate) {
            case 44100:
              meta.sampleRateIndex = 4;
              break;
            case 22050:
              meta.sampleRateIndex = 7;
              break;
            case 11025:
              meta.sampleRateIndex = 10;
              break;
          }
        }
        if (videoTrack && !videoTrack.hasSpecificConfig) {
          var _meta = videoTrack.meta;
          if (typeof onMetaData.framerate === 'number') {
            var fpsNum = Math.floor(onMetaData.framerate * 1000);
            if (fpsNum > 0) {
              var fps = fpsNum / 1000;
              if (!_meta.frameRate) {
                _meta.frameRate = {};
              }
              _meta.frameRate.fixed = true;
              _meta.frameRate.fps = fps;
              _meta.frameRate.fps_num = fpsNum;
              _meta.frameRate.fps_den = 1000;
            }
          }
        }
      }
    }, {
      key: '_aacSequenceHeaderParser',
      value: function _aacSequenceHeaderParser(data) {
        var ret = {};
        ret.hasSpecificConfig = true;
        ret.objectType = data[1] >>> 3;
        ret.sampleRateIndex = (data[1] & 7) << 1 | data[2] >>> 7;
        ret.audiosamplerate = this._switchAudioSampleRate(ret.sampleRateIndex);
        ret.channelCount = (data[2] & 120) >>> 3;
        ret.frameLength = (data[2] & 4) >>> 2;
        ret.dependsOnCoreCoder = (data[2] & 2) >>> 1;
        ret.extensionFlagIndex = data[2] & 1;

        var userAgent = window.navigator.userAgent.toLowerCase();
        var extensionSamplingIndex = void 0;

        var config = void 0;
        var samplingIndex = ret.sampleRateIndex;

        if (userAgent.indexOf('firefox') !== -1) {
          // firefox: use SBR (HE-AAC) if freq less than 24kHz
          if (ret.sampleRateIndex >= 6) {
            ret.objectType = 5;
            config = new Array(4);
            extensionSamplingIndex = samplingIndex - 3;
          } else {
            // use LC-AAC
            ret.objectType = 2;
            config = new Array(2);
            extensionSamplingIndex = samplingIndex;
          }
        } else if (userAgent.indexOf('android') !== -1 || userAgent.indexOf('safari') !== -1) {
          // android: always use LC-AAC
          ret.objectType = 2;
          config = new Array(2);
          extensionSamplingIndex = samplingIndex;
        } else {
          // for other browsers, e.g. chrome...
          // Always use HE-AAC to make it easier to switch aac codec profile
          ret.objectType = 5;
          extensionSamplingIndex = ret.sampleRateIndex;
          config = new Array(4);

          if (ret.sampleRateIndex >= 6) {
            extensionSamplingIndex = ret.sampleRateIndex - 3;
          } else if (ret.channelCount === 1) {
            // Mono channel
            ret.objectType = 2;
            config = new Array(2);
            extensionSamplingIndex = ret.sampleRateIndex;
          }
        }
        ret.codec = 'mp4a.40.' + ret.objectType;
        config[0] = ret.objectType << 3;
        config[0] |= (ret.sampleRateIndex & 0x0F) >>> 1;
        config[1] = (ret.sampleRateIndex & 0x0F) << 7;
        config[1] |= (ret.channelCount & 0x0F) << 3;
        if (ret.objectType === 5) {
          config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;
          config[2] = (extensionSamplingIndex & 0x01) << 7;
          // extended audio object type: force to 2 (LC-AAC)
          config[2] |= 2 << 2;
          config[3] = 0;
        }
        ret.config = config;
        return ret;
      }
    }, {
      key: '_parseAACData',
      value: function _parseAACData(chunk) {
        var track = this.tracks.audioTrack;
        if (!track) {
          return;
        }

        var meta = track.meta;

        if (!meta) {
          track.meta = new AudioTrackMeta();
          meta = track.meta;
        }

        var info = this.loaderBuffer.shift(1)[0];

        chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);

        var format = (info & 240) >>> 4;

        track.format = format;

        if (format !== 10) {
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, new Error('invalid audio format: ' + format));
        }

        if (format === 10 && !this._hasAudioSequence) {
          meta.sampleRate = this._switchAudioSamplingFrequency(info);
          meta.sampleRateIndex = (info & 12) >>> 2;
          meta.frameLenth = (info & 2) >>> 1;
          meta.channelCount = info & 1;
          meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);
        }

        var audioSampleRate = meta.audioSampleRate;
        var audioSampleRateIndex = meta.sampleRateIndex;
        var refSampleDuration = meta.refSampleDuration;

        delete chunk.tagType;
        var validate = this._datasizeValidator(chunk.datasize);

        if (chunk.data[0] === 0) {
          // AAC Sequence Header
          var aacHeader = this._aacSequenceHeaderParser(chunk.data);
          audioSampleRate = aacHeader.audiosamplerate || meta.audioSampleRate;
          audioSampleRateIndex = aacHeader.sampleRateIndex || meta.sampleRateIndex;
          refSampleDuration = Math.floor(1024 / audioSampleRate * meta.timescale);

          meta.channelCount = aacHeader.channelCount;
          meta.sampleRate = audioSampleRate;
          meta.sampleRateIndex = audioSampleRateIndex;
          meta.refSampleDuration = refSampleDuration;
          meta.duration = this._context.mediaInfo.duration * meta.timescale;
          meta.config = aacHeader.config;
          meta.objectType = aacHeader.objectType;

          var audioMedia = this._context.mediaInfo.audio;

          // fill audio media info
          audioMedia.codec = aacHeader.codec;
          audioMedia.channelCount = aacHeader.channelCount;
          audioMedia.sampleRate = audioSampleRate;
          audioMedia.sampleRateIndex = aacHeader.audioSampleRateIndex;

          if (!this._hasAudioSequence) {
            this.emit(DEMUX_EVENTS$2.METADATA_PARSED, 'audio');
          } else {
            this.emit(DEMUX_EVENTS$2.AUDIO_METADATA_CHANGE);
            // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio')
          }
          this._hasAudioSequence = true;

          this._audioMetaChange = true;
        } else {
          if (this._audioMetaChange) {
            chunk.options = {
              meta: track.meta
            };
            this._audioMetaChange = false;
          }

          chunk.data = chunk.data.slice(1, chunk.data.length);
          track.samples.push(chunk);
        }
        if (!validate) {
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, this.TAG, new Error('TAG length error at ' + chunk.datasize), false);
          // this.logger.warn(this.TAG, error.message)
        }
      }

      /**
       * parse hevc/avc video data
       * @param chunk
       * @private
       */

    }, {
      key: '_parseHevcData',
      value: function _parseHevcData(chunk) {
        // header
        var info = this.loaderBuffer.shift(1)[0];
        chunk.frameType = (info & 0xf0) >>> 4;
        chunk.isKeyframe = chunk.frameType === 1;
        // let tempCodecID = this.tracks.videoTrack.codecID
        var codecID = info & 0x0f;
        this.tracks.videoTrack.codecID = codecID;

        // hevc和avc的header解析方式一样
        chunk.avcPacketType = this.loaderBuffer.shift(1)[0];
        chunk.cts = this.loaderBuffer.toInt(0, 3);
        this.loaderBuffer.shift(3);

        // 12 for hevc, 7 for avc
        if (codecID === 7 || codecID === 12) {
          var data = this.loaderBuffer.shift(chunk.datasize - 5);
          if (data[4] === 0 && data[5] === 0 && data[6] === 0 && data[7] === 1) {
            var avcclength = 0;
            for (var i = 0; i < 4; i++) {
              avcclength = avcclength * 256 + data[i];
            }
            avcclength -= 4;
            data = data.slice(4, data.length);
            data[3] = avcclength % 256;
            avcclength = (avcclength - data[3]) / 256;
            data[2] = avcclength % 256;
            avcclength = (avcclength - data[2]) / 256;
            data[1] = avcclength % 256;
            data[0] = (avcclength - data[1]) / 256;
          }

          chunk.data = data;
          // If it is AVC sequece Header.
          if (chunk.avcPacketType === 0) {
            if (codecID === 12) {
              this._hevcSequenceHeaderParser(chunk.data);
            } else {
              this._avcSequenceHeaderParser(chunk.data);
            }
            var validate = this._datasizeValidator(chunk.datasize);
            if (validate) {
              if (!this._hasVideoSequence) {
                this.emit(DEMUX_EVENTS$2.METADATA_PARSED, 'video');
              } else {
                this.emit(DEMUX_EVENTS$2.VIDEO_METADATA_CHANGE);
                // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video')
              }
              this._hasVideoSequence = true;
            }
            this._videoMetaChange = true;
          } else {
            if (!this._datasizeValidator(chunk.datasize)) {
              this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, this.TAG, new Error('invalid video tag datasize: ' + chunk.datasize), false);
              return;
            }
            var nals = codecID === 12 ? NalUnitHEVC$1.getHvccNals(new Stream(chunk.data.buffer)) : NalUnit.getAvccNals(new Stream(chunk.data.buffer));
            for (var _i = 0; _i < nals.length; _i++) {
              var unit = nals[_i];
              codecID === 12 ? NalUnitHEVC$1.analyseNal(unit) : NalUnit.analyseNal(unit);

              if (unit.sei) {
                this.emit(DEMUX_EVENTS$2.SEI_PARSED, Object.assign(unit.sei, {
                  dts: chunk.dts
                }));
              }
            }
            codecID === 12 ? this.tracks.videoTrack.meta.streamType = 0x24 : this.tracks.videoTrack.meta.streamType = 0x1b;
            if (this._videoMetaChange) {
              chunk.options = {
                meta: Object.assign({}, this.tracks.videoTrack.meta)
              };
              this._videoMetaChange = false;
            }
            this.tracks.videoTrack.samples.push(chunk);
            // this.emit(DEMUX_EVENTS.DEMUX_COMPLETE)
          }
        } else {
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, this.TAG, new Error('video codeid is ' + codecID), false);
          chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);
          if (!this._datasizeValidator(chunk.datasize)) {
            this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, this.TAG, new Error('invalid video tag datasize: ' + chunk.datasize), false);
          }

          this.tracks.videoTrack.samples.push(chunk);
          this.emit(DEMUX_EVENTS$2.DEMUX_COMPLETE);
        }
        delete chunk.tagType;
      }

      /**
       * parse avc metadata
       * @param data
       * @private
       */

    }, {
      key: '_avcSequenceHeaderParser',
      value: function _avcSequenceHeaderParser(data) {
        var track = this.tracks.videoTrack;

        if (!track) {
          return;
        }

        var offset = 0;

        if (!track.meta) {
          track.meta = new VideoTrackMeta();
        }
        var meta = track.meta;

        meta.configurationVersion = data[0];
        meta.avcProfileIndication = data[1];
        meta.profileCompatibility = data[2];
        meta.avcLevelIndication = data[3] / 10;
        meta.nalUnitLength = (data[4] & 0x03) + 1;

        var numOfSps = data[5] & 0x1f;
        offset = 6;
        var config = {};

        // parse SPS
        for (var i = 0; i < numOfSps; i++) {
          var size = data[offset] * 255 + data[offset + 1];
          offset += 2;

          var sps = new Uint8Array(size);
          for (var j = 0; j < size; j++) {
            sps[j] = data[offset + j];
          }

          // codec string
          var codecString = 'avc1.';
          for (var _j = 1; _j < 4; _j++) {
            var h = sps[_j].toString(16);
            if (h.length < 2) {
              h = '0' + h;
            }
            codecString += h;
          }

          meta.codec = codecString;

          offset += size;
          this.tracks.videoTrack.meta.sps = sps;
          config = SpsParser.parseSPS(sps);
        }

        var numOfPps = data[offset];

        offset++;

        for (var _i2 = 0; _i2 < numOfPps; _i2++) {
          var _size = data[offset] * 255 + data[offset + 1];
          offset += 2;
          var pps = new Uint8Array(_size);
          for (var _j2 = 0; _j2 < _size; _j2++) {
            pps[_j2] = data[offset + _j2];
          }
          offset += _size;
          this.tracks.videoTrack.meta.pps = pps;
        }

        Object.assign(meta, SpsParser.toVideoMeta(config));

        // fill video media info
        var videoMedia = this._context.mediaInfo.video;

        videoMedia.codec = meta.codec;
        videoMedia.profile = meta.profile;
        videoMedia.level = meta.level;
        videoMedia.chromaFormat = meta.chromaFormat;
        videoMedia.frameRate = meta.frameRate;
        videoMedia.parRatio = meta.parRatio;
        videoMedia.width = videoMedia.width === meta.presentWidth ? videoMedia.width : meta.presentWidth;
        videoMedia.height = videoMedia.height === meta.presentHeight ? videoMedia.width : meta.presentHeight;

        meta.duration = this._context.mediaInfo.duration * meta.timescale;
        meta.avcc = new Uint8Array(data.length);
        meta.avcc.set(data);
        meta.streamType = 0x1b;

        track.meta = meta;
      }

      /**
       * parse hevc metadata
       * @param data
       * @private
       */

    }, {
      key: '_hevcSequenceHeaderParser',
      value: function _hevcSequenceHeaderParser(data) {
        var track = this.tracks.videoTrack;

        if (!track) {
          return;
        }

        var offset = 0;

        if (!track.meta) {
          track.meta = new VideoTrackMeta();
        }
        var meta = track.meta;

        meta.configurationVersion = data[0];
        meta.hevcProfileSpace = (data[1] & 0xc0) >>> 6;
        meta.hevcTierFlag = (data[1] & 0x20) >>> 5;
        meta.hevcProfileIdc = data[1] & 0x1f;
        meta.hevcProfileCompatibilityFlags = [data[2], data[3], data[4], data[5]];
        meta.hevcConstraintIndicatorFlags = [data[6], data[7], data[8], data[9], data[10], data[11]];
        meta.hevcLevelIdc = data[12];
        meta.minSpatialSegmentationIdc = data[13] & 0x0f + data[14] << 4;
        meta.parallelismType = data[15] & 0x03;
        meta.chromaFormat = data[16] & 0x03;
        meta.bitDepthLumaMinus8 = data[17] & 0x07;
        meta.bitDepthChromaMinus8 = data[18] & 0x07;
        meta.avgFrameRate = data[19] * 256 + data[20];
        meta.constantFrameRate = (data[21] & 0xc0) >>> 6;
        meta.numTemporalLayers = (data[21] & 0x38) >>> 3;
        meta.temporalIdNested = (data[21] & 0x04) >>> 2;
        meta.lengthSizeMinusOne = data[21] & 0x03;
        var numOfArrays = data[22];

        offset = 23;
        var config = {};
        var nalUnitType = 0;
        var numNalus = 0;
        var nalUnitSize = 0;
        var hasVPS = false;
        var hasSPS = false;
        var hasPPS = false;
        var vps = void 0,
            sps = void 0,
            pps = void 0;
        for (var i = 0; i < numOfArrays; i++) {
          nalUnitType = data[offset] & 0x3f;
          numNalus = data[offset + 1] * 256 + data[offset + 2];
          offset += 3;
          for (var j = 0; j < numNalus; j++) {
            nalUnitSize = data[offset] * 256 + data[offset + 1];
            switch (nalUnitType) {
              case 32:
                if (!hasVPS) {
                  hasVPS = true;
                  vps = data.slice(offset + 2, offset + 2 + nalUnitSize);
                  this.tracks.videoTrack.meta.vps = SpsParserHEVC._ebsp2rbsp(vps);
                }
                break;
              case 33:
                if (!hasSPS) {
                  hasSPS = true;
                  sps = data.slice(offset + 2, offset + 2 + nalUnitSize);
                  this.tracks.videoTrack.meta.sps = SpsParserHEVC._ebsp2rbsp(sps);
                  meta.codec = 'hev1.1.6.L93.B0';
                  config = SpsParserHEVC.parseSPS(sps);
                }
                break;
              case 34:
                if (!hasPPS) {
                  hasPPS = true;
                  pps = data.slice(offset + 2, offset + 2 + nalUnitSize);
                  this.tracks.videoTrack.meta.pps = SpsParserHEVC._ebsp2rbsp(pps);
                }
                break;
            }
            offset += 2 + nalUnitSize;
          }
        }

        Object.assign(meta, SpsParserHEVC.toVideoMeta(config));

        // fill video media info
        var videoMedia = this._context.mediaInfo.video;

        videoMedia.codec = meta.codec;
        videoMedia.profile = meta.profile;
        videoMedia.level = meta.level;
        videoMedia.chromaFormat = meta.chromaFormat;
        videoMedia.frameRate = meta.frameRate;
        videoMedia.parRatio = meta.parRatio;
        videoMedia.width = videoMedia.width === meta.presentWidth ? videoMedia.width : meta.presentWidth;
        videoMedia.height = videoMedia.height === meta.presentHeight ? videoMedia.width : meta.presentHeight;

        meta.duration = this._context.mediaInfo.duration * meta.timescale;

        meta.streamType = 0x24;

        track.meta = meta;
      }

      /**
       * choose audio sample rate
       * @param samplingFrequencyIndex
       * @returns {number}
       * @private
       */

    }, {
      key: '_switchAudioSampleRate',
      value: function _switchAudioSampleRate(samplingFrequencyIndex) {
        var samplingFrequencyList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
        return samplingFrequencyList[samplingFrequencyIndex];
      }

      /**
       * choose audio sampling frequence
       * @param info
       * @returns {number}
       * @private
       */

    }, {
      key: '_switchAudioSamplingFrequency',
      value: function _switchAudioSamplingFrequency(info) {
        var samplingFrequencyIndex = (info & 12) >>> 2;
        var samplingFrequencyList = [5500, 11025, 22050, 44100, 48000];
        return samplingFrequencyList[samplingFrequencyIndex];
      }

      /**
       * choose audio channel count
       * @param info
       * @returns {number}
       * @private
       */

    }, {
      key: '_switchAudioChannel',
      value: function _switchAudioChannel(info) {
        var sampleTrackNumIndex = info & 1;
        var sampleTrackNumList = [1, 2];
        return sampleTrackNumList[sampleTrackNumIndex];
      }

      /**
       * check datasize is valid use 4 Byte after current tag
       * @param datasize
       * @returns {boolean}
       * @private
       */

    }, {
      key: '_datasizeValidator',
      value: function _datasizeValidator(datasize) {
        var datasizeConfirm = this.loaderBuffer.toInt(0, 4);
        this.loaderBuffer.shift(4);
        return datasizeConfirm === datasize + 11;
      }
    }, {
      key: 'loaderBuffer',
      get: function get() {
        var buffer = this._context.getInstance('LOADER_BUFFER');
        if (buffer) {
          return buffer;
        } else {
          this.emit(DEMUX_EVENTS$2.DEMUX_ERROR, new Error('找不到 loaderBuffer 实例'));
        }
      }
    }, {
      key: 'tracks',
      get: function get() {
        return this._context.getInstance('TRACKS');
      }
    }, {
      key: 'logger',
      get: function get() {
        return this._context.getInstance('LOGGER');
      }
    }], [{
      key: 'isFlvFile',
      value: function isFlvFile(data) {
        return !(data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01);
      }

      /**
       * If the stream has audio or video.
       * @param {number} streamFlag - Data from the stream which is define whether the audio / video track is exist.
       */

    }, {
      key: 'getPlayType',
      value: function getPlayType(streamFlag) {
        var result = {
          hasVideo: false,
          hasAudio: false
        };

        if (streamFlag & 0x01 > 0) {
          result.hasVideo = true;
        }

        if (streamFlag & 0x04 > 0) {
          result.hasAudio = true;
        }

        return result;
      }
    }]);

    return FlvDemuxer;
  }();

  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _typeof$2 = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
  };

  var _createClass$p = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$p(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var LOADER_EVENTS$2 = EVENTS.LOADER_EVENTS;
  var READ_STREAM = 0;
  var READ_TEXT = 1;
  var READ_JSON = 2;
  var READ_BUFFER = 3;

  var FetchLoader = function () {
    function FetchLoader(configs) {
      _classCallCheck$p(this, FetchLoader);

      this.configs = Object.assign({}, configs);
      this.url = null;
      this.status = 0;
      this.error = null;
      this._reader = null;
      this._canceled = false;
      this._destroyed = false;
      this.readtype = this.configs.readtype;
      this.buffer = this.configs.buffer || 'LOADER_BUFFER';
      this._loaderTaskNo = 0;
    }

    _createClass$p(FetchLoader, [{
      key: 'init',
      value: function init() {
        this.on(LOADER_EVENTS$2.LADER_START, this.load.bind(this));
      }
    }, {
      key: 'fetch',
      value: function (_fetch) {
        function fetch(_x, _x2) {
          return _fetch.apply(this, arguments);
        }

        fetch.toString = function () {
          return _fetch.toString();
        };

        return fetch;
      }(function (url, params) {
        var timer = null;
        return Promise.race([fetch(url, params), new Promise(function (resolve, reject) {
          timer = setTimeout(function () {
            reject(new Error('fetch timeout'));
          }, 1e4); // 10s
        })]).then(function (response) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          return response;
        });
      })
    }, {
      key: 'internalLoad',
      value: function internalLoad(url, params, retryTimes) {
        var _this2 = this;

        return this.fetch(this.url, params).then(function (response) {
          _this2.emit(LOADER_EVENTS$2.LOADER_RESPONSE_HEADERS, _this2.TAG, response.headers);

          if (response.ok) {
            _this2.status = response.status;
            Promise.resolve().then(function () {
              _this2._onFetchResponse(response);
            });

            return Promise.resolve(response);
          }

          if (retryTimes-- > 0) {
            _this2.internalLoad(url, params, retryTimes);
          } else {
            _this2.loading = false;
            _this2.emit(LOADER_EVENTS$2.LOADER_ERROR, _this2.TAG, new Error(response.status + ' (' + response.statusText + ')'));
          }
        }).catch(function (error) {
          _this2.loading = false;
          if (retryTimes-- > 0) {
            _this2.internalLoad(url, params, retryTimes);
          } else {
            _this2.emit(LOADER_EVENTS$2.LOADER_ERROR, _this2.TAG, error);
            throw error;
          }
        });
      }
    }, {
      key: 'load',
      value: function load(url) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var retryTimes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;

        this.url = url;

        this._canceled = false;

        // TODO: Add Ranges
        var params = this.getParams(opts);
        this.loading = true;
        this.internalLoad(url, params, retryTimes);
      }
    }, {
      key: '_onFetchResponse',
      value: function _onFetchResponse(response) {
        var _this = this;
        var buffer = this._context.getInstance(this.buffer);
        this._loaderTaskNo++;
        var taskno = this._loaderTaskNo;
        if (response.ok === true) {
          switch (this.readtype) {
            case READ_JSON:
              response.json().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(data);
                    _this.emit(LOADER_EVENTS$2.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$2.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_TEXT:
              response.text().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(data);
                    _this.emit(LOADER_EVENTS$2.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$2.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_BUFFER:
              response.arrayBuffer().then(function (data) {
                _this.loading = false;
                if (!_this._canceled && !_this._destroyed) {
                  if (buffer) {
                    buffer.push(new Uint8Array(data));
                    _this.emit(LOADER_EVENTS$2.LOADER_COMPLETE, buffer);
                  } else {
                    _this.emit(LOADER_EVENTS$2.LOADER_COMPLETE, data);
                  }
                }
              });
              break;
            case READ_STREAM:
            default:
              return this._onReader(response.body.getReader(), taskno);
          }
        }
      }
    }, {
      key: '_onReader',
      value: function _onReader(reader, taskno) {
        var _this3 = this;

        var buffer = this._context.getInstance(this.buffer);
        if (!buffer && this._reader || this._destroyed) {
          try {
            this._reader.cancel();
          } catch (e) {
            // DO NOTHING
          }
        }

        this._reader = reader;
        if (this.loading === false) {
          return;
        }

        // reader read function returns a Promise. get data when callback and has value.done when disconnected.
        // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。
        this._reader && this._reader.read().then(function (val) {
          if (_this3._canceled || _this3._destroyed) {
            if (_this3._reader) {
              try {
                _this3._reader.cancel();
              } catch (e) {
                // DO NOTHING
              }
            }
            return;
          }
          if (val.done) {
            _this3.loading = false;
            _this3.status = 0;
            Promise.resolve().then(function () {
              _this3.emit(LOADER_EVENTS$2.LOADER_COMPLETE, buffer);
            });
            return;
          }

          buffer.push(val.value);
          Promise.resolve().then(function () {
            _this3.emit(LOADER_EVENTS$2.LOADER_DATALOADED, buffer);
          });
          return _this3._onReader(reader, taskno);
        }).catch(function (error) {
          _this3.loading = false;
          _this3.emit(LOADER_EVENTS$2.LOADER_ERROR, _this3.TAG, error);
          throw error;
        });
      }
    }, {
      key: 'getParams',
      value: function getParams(opts) {
        var options = Object.assign({}, opts);
        var headers = new Headers();

        var params = {
          method: 'GET',
          headers: headers,
          mode: 'cors',
          cache: 'default'

          // add custmor headers
          // 添加自定义头
        };if (_typeof$2(this.configs.headers) === 'object') {
          var configHeaders = this.configs.headers;
          for (var key in configHeaders) {
            if (configHeaders.hasOwnProperty(key)) {
              headers.append(key, configHeaders[key]);
            }
          }
        }

        if (_typeof$2(options.headers) === 'object') {
          var optHeaders = options.headers;
          for (var _key in optHeaders) {
            if (optHeaders.hasOwnProperty(_key)) {
              headers.append(_key, optHeaders[_key]);
            }
          }
        }

        if (options.cors === false) {
          params.mode = 'same-origin';
        }

        // withCredentials is disabled by default
        // withCredentials 在默认情况下不被使用。
        if (options.withCredentials) {
          params.credentials = 'include';
        }

        // TODO: Add ranges;
        return params;
      }
    }, {
      key: 'cancel',
      value: function cancel() {
        if (this._reader) {
          try {
            this._reader.cancel();
          } catch (e) {
            // 防止failed: 200错误被打印到控制台上
          }
          this._reader = null;
          this.loading = false;
        }
        this._canceled = true;
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._destroyed = true;
        this.cancel();
      }
    }], [{
      key: 'type',
      get: function get() {
        return 'loader';
      }
    }]);

    return FetchLoader;
  }();

  var _createClass$q = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  function _classCallCheck$q(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var XgBuffer = function () {
    /**
     * A buffer to store loaded data.
     *
     * @class LoaderBuffer
     * @param {number} length - Optional the buffer size
     */
    function XgBuffer(length) {
      _classCallCheck$q(this, XgBuffer);

      this.length = length || 0;
      this.historyLen = length || 0;
      this.array = [];
      this.offset = 0;
    }

    /**
     * The function to push data.
     *
     * @param {Uint8Array} data - The data to push into the buffer
     */

    _createClass$q(XgBuffer, [{
      key: "push",
      value: function push(data) {
        this.array.push(data);
        this.length += data.byteLength;
        this.historyLen += data.byteLength;
      }

      /**
       * The function to shift data.
       *
       * @param {number} length - The size of shift.
       */

    }, {
      key: "shift",
      value: function shift(length) {
        if (this.array.length < 1) {
          return new Uint8Array(0);
        }

        if (length === undefined) {
          return this._shiftBuffer();
        }
        if (this.offset + length === this.array[0].length) {
          var _ret = this.array[0].slice(this.offset, this.offset + length);
          this.offset = 0;
          this.array.shift();
          this.length -= length;
          return _ret;
        }

        if (this.offset + length < this.array[0].length) {
          var _ret2 = this.array[0].slice(this.offset, this.offset + length);
          this.offset += length;
          this.length -= length;
          return _ret2;
        }

        var ret = new Uint8Array(length);
        var tmpoff = 0;
        while (this.array.length > 0 && length > 0) {
          if (this.offset + length < this.array[0].length) {
            var tmp = this.array[0].slice(this.offset, this.offset + length);
            ret.set(tmp, tmpoff);
            this.offset += length;
            this.length -= length;
            length = 0;
            break;
          } else {
            // console.log('mark1')
            var templength = this.array[0].length - this.offset;
            ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);
            this.array.shift();
            this.offset = 0;
            tmpoff += templength;
            this.length -= templength;
            length -= templength;
          }
        }
        return ret;
      }

      /**
       * Function to clear the buffer.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.array = [];
        this.length = 0;
        this.offset = 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.clear();
        this.historyLen = 0;
      }

      /**
       * Function to shift one unit8Array.
       */

    }, {
      key: "_shiftBuffer",
      value: function _shiftBuffer() {
        this.length -= this.array[0].length;
        this.offset = 0;
        return this.array.shift();
      }

      /**
       * Convert uint8 data to number.
       *
       * @param {number} start - the start postion.
       * @param {number} length - the length of data.
       */

    }, {
      key: "toInt",
      value: function toInt(start, length) {
        var retInt = 0;
        var i = this.offset + start;
        while (i < this.offset + length + start) {
          if (i < this.array[0].length) {
            retInt = retInt * 256 + this.array[0][i];
          } else if (this.array[1]) {
            retInt = retInt * 256 + this.array[1][i - this.array[0].length];
          }

          i++;
        }
        return retInt;
      }
    }]);

    return XgBuffer;
  }();

  var _createClass$r = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$r(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Logger = function () {
    function Logger() {
      _classCallCheck$r(this, Logger);
    }

    _createClass$r(Logger, [{
      key: 'warn',
      value: function warn() {}
    }]);

    return Logger;
  }();

  var defaultConfig = {
    FlvDemuxer: FlvDemuxer,
    FetchLoader: FetchLoader,
    Tracks: Track,
    XgBuffer: XgBuffer,
    Logger: Logger
  };

  var _get$1 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

  var _createClass$s = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck$s(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
  // import 'xgplayer-mobilevideo'
  var flvAllowedEvents = EVENTS.FlvAllowedEvents;

  var FlvPlayer = function (_Player) {
    _inherits$2(FlvPlayer, _Player);

    _createClass$s(FlvPlayer, null, [{
      key: 'isSupported',
      value: function isSupported() {
        var wasmSupported = 'WebAssembly' in window;
        var WebComponentSupported = 'customElements' in window && window.customElements.define;
        var isComponentDefined = false;
        if (WebComponentSupported) {
          isComponentDefined = window.customElements.get('mobile-video');
        }
        return wasmSupported && isComponentDefined;
      }
    }]);

    function FlvPlayer(config) {
      _classCallCheck$s(this, FlvPlayer);

      if (!config.mediaType) {
        config.mediaType = 'mobile-video';
        if (config.videoConfig) {
          config.videoConfig.preloadtime = config.preloadTime || 5;
        } else {
          config.videoConfig = {
            preloadtime: config.preloadTime || 5
          };
        }
      }

      var _this = _possibleConstructorReturn$2(this, (FlvPlayer.__proto__ || Object.getPrototypeOf(FlvPlayer)).call(this, config));

      _this.config = Object.assign({}, defaultConfig, _this.config);
      if (!_this.playerInited) {
        _this.initPlayer(config);
      }
      return _this;
    }

    _createClass$s(FlvPlayer, [{
      key: 'initPlayer',
      value: function initPlayer() {
        this.video.width = Number.parseInt(this.config.width || 600);
        this.video.height = Number.parseInt(this.config.height || 337.5);
        this.video.style.outline = 'none';
        this.context = new Context(flvAllowedEvents);
        this.playerInited = true;
      }
    }, {
      key: 'start',
      value: function start() {
        if (!this.playerInited) {
          this.initPlayer();
        }
        this.initFlv();
        this.context.init();
        this.flv.seek(0);
        _get$1(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'start', this).call(this, this.config.url);
        // this.play();
      }
    }, {
      key: 'initFlvEvents',
      value: function initFlvEvents(flv) {
        var player = this;

        flv.once(EVENTS.LOADER_EVENTS.LOADER_COMPLETE, function () {
          // 直播完成，待播放器播完缓存后发送关闭事件
          if (!player.paused) {
            var timer = setInterval(function () {
              var end = player.getBufferedRange()[1];
              if (Math.abs(player.currentTime - end) < 0.5) {
                // player.emit('ended')
                if (player.video) {
                  player.video.handleEnded();
                }
                window.clearInterval(timer);
              }
            }, 200);
          }
        });
      }
    }, {
      key: 'initFlv',
      value: function initFlv() {
        var flv = this.context.registry('FLV_CONTROLLER', FlvController)(this);
        this.initFlvEvents(flv);
        this.flv = flv;
      }
    }, {
      key: 'play',
      value: function play() {
        if (this._hasStart && this.paused) {
          this._destroy();
          this.context = new Context(flvAllowedEvents);
          var flv = this.context.registry('FLV_CONTROLLER', FlvController)(this);
          this.initFlvEvents(flv);
          this.flv = flv;
          this.context.init();
          this.loadData();
          _get$1(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'start', this).call(this);
          _get$1(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'play', this).call(this);
        } else {
          _get$1(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'play', this).call(this);
          this.addLiveFlag();
        }
      }
    }, {
      key: 'pause',
      value: function pause() {
        _get$1(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'pause', this).call(this);
        if (this.flv) {
          this.flv.pause();
        }
      }
    }, {
      key: 'loadData',
      value: function loadData() {
        var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;

        if (this.flv) {
          this.flv.seek(time);
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var isDelDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this._destroy();
        var video = this.video,
            root = this.root;

        _get$1(FlvPlayer.prototype.__proto__ || Object.getPrototypeOf(FlvPlayer.prototype), 'destroy', this).call(this, isDelDOM);
        if (video && video.remove) {
          video.remove();
        } else if (root) {
          root.removeChild(video);
        }
      }
    }, {
      key: 'addLiveFlag',
      value: function addLiveFlag() {
        var player = this;
        Player.util.addClass(player.root, 'xgplayer-is-live');
        if (!Player.util.findDom(this.root, 'xg-live')) {
          var live = Player.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');
          player.controls.appendChild(live);
        }
      }
    }, {
      key: '_destroy',
      value: function _destroy() {
        this.context.destroy();
        this.flv = null;
        this.context = null;
      }
    }, {
      key: 'src',
      get: function get() {
        return this.currentSrc;
      },
      set: function set(url) {
        this.config.url = url;
        if (!this.paused) {
          this.currentTime = 0;
          this.pause();
          // this.once('pause', () => {
          //   this.start(url)
          // })
          this.play();
        } else {
          this.start(url);
        }
      }
    }]);

    return FlvPlayer;
  }(Player);

  return FlvPlayer;

})));
//# sourceMappingURL=index.js.map
