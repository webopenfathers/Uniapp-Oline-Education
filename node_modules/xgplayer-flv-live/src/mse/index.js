import Player from 'xgplayer'
import { EVENTS, Context } from 'xgplayer-helper-utils'
import FLV from './flv-live'
import defaultConfig from './config'
const flvAllowedEvents = EVENTS.FlvAllowedEvents;

class FlvPlayer extends Player {
  static isSupported () {
    return window.MediaSource &&
      window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
  }

  static install (name, plugin) {
    return Player.install(name, plugin)
  }

  constructor (config) {
    super(config)
    this.config = Object.assign({}, defaultConfig, this.config)
    this.initEvents()
    this.loaderCompleteTimer = null
    this.hasPlayed = false;
    // const preloadTime = player.config.preloadTime || 15
  }

  start () {
    if (this.started) {
      return;
    }
    if (this.context) {
      this.context.destroy();
    }
    this.context = new Context(this, this.config, flvAllowedEvents)
    this.initFlv()
    this.context.init()
    super.start(this.flv.mse.url)
    this.loadData()
    this.started = true
  }

  initFlvEvents (flv) {
    const player = this;

    flv.once(EVENTS.REMUX_EVENTS.INIT_SEGMENT, () => {
      Player.util.addClass(player.root, 'xgplayer-is-live')
    })

    flv.on(EVENTS.LOADER_EVENTS.LOADER_COMPLETE, () => {
      // 直播完成，待播放器播完缓存后发送关闭事件
      if (!player.paused) {
        if (this.video) {
          const end = this.getBufferedRange()[1]
          const restTime = end - this.currentTime;
          setTimeout(() => {
            this.emit('ended')
          }, restTime * 1000)
        }
      } else {
        player.emit('ended')
      }
    })
  }

  initFlvBackupEvents (flv, ctx) {
    let mediaLength = 3;
    flv.on(EVENTS.REMUX_EVENTS.MEDIA_SEGMENT, () => {
      mediaLength -= 1;
      if (mediaLength === 0) {
        // ensure switch smoothly
        this.flv = flv;
        this.mse.resetContext(ctx);
        this.context.destroy();
        this.context = ctx;
        if (this.paused) {
          super.play();
        }
      }
    })

    flv.once(EVENTS.LOADER_EVENTS.LOADER_COMPLETE, () => {
      // 直播完成，待播放器播完缓存后发送关闭事件
      if (!this.paused) {
        if (this.video) {
          const end = this.getBufferedRange()[1]
          const restTime = end - this.currentTime;
          setTimeout(() => {
            this.emit('ended')
          }, restTime * 1000)
        }
      } else {
        this.emit('ended')
      }
    })

    flv.once(EVENTS.LOADER_EVENTS.LOADER_ERROR, () => {
      ctx.destroy()
    })
  }

  initEvents () {
    this.on('seeking', () => {
      const time = this.currentTime
      const range = this.getBufferedRange()
      if (time > range[1] || time < range[0]) {
        this.flv.seek(this.currentTime)
      }
    });

    // support for old version xgplayer
    this.once('play', () => {
      this.hasPlayed = true;
    })
  }

  initFlv () {
    const flv = this.context.registry('FLV_CONTROLLER', FLV)(this, { retryTimes: this.config.retryTimes });
    this.initFlvEvents(flv)
    this.flv = flv
    this.mse = flv.mse;
    return flv;
  }

  play () {
    if (this.paused && this.hasPlayed) {
      return this.mse.cleanBuffers().then(() => {
        this.started = false;
        this.start();
        return super.play()
      })
    } else {
      this.hasPlayed = true;
      return super.play()
    }
  }

  pause () {
    super.pause()
    if (this.flv) {
      this.flv.pause()
      this.hasPlayed = true;
    }
  }

  loadData (time = this.currentTime) {
    if (this.flv) {
      this.flv.seek(time)
    }
  }

  destroy () {
    const prom = new Promise((resolve) => {
      this._destroy().then(resolve).catch(resolve)
      setTimeout(() => {
        resolve()
      }, 50)
    })
    super.destroy();
    return prom;
  }

  _destroy () {
    if (this.context) {
      this.context.destroy()
    }
    if (this.newContext) {
      this.newContext.destroy()
    }
    const work = () => {
      this.flv = null;
      this.context = null;
      this.newFlv = null;
      this.newContext = null;
    }
    if (this.flv && this.flv.mse) {
      return this.flv.mse.destroy().then(() => {
        work();
      })
    }
    return Promise.resolve().then(() => {
      work()
    })
  }

  get src () {
    return this.currentSrc
  }

  set src (url) {
    this.switchURL(url)
  }

  get core () {
    return this.flv;
  }

  /**
   * switch to another flv live url
   * @param url
   * @param seamless
   */
  switchURL (url, seamless = true) {
    if (!seamless) {
      this.pause();
      this.context.destroy();
    }
    const context = new Context(this, this.config, flvAllowedEvents);
    const flv = context.registry('FLV_CONTROLLER', FLV)(this, { retryTimes: this.config.retryTimes }, this.mse);
    this.newContext = context;
    this.newFlv = flv;
    context.init()
    this.initFlvBackupEvents(flv, context);
    flv.loadData(url);
  }
}

export default FlvPlayer
